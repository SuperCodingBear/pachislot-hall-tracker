<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Project A Hall Tracker</title>
  <meta name="description" content="Pachislot Parlour Management System - 24/7 Hall Operations Tracker">
  <script src="https://cdn.tailwindcss.com"></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/recharts@2.5.0/dist/Recharts.js"></script>
  <script src="https://unpkg.com/lucide-react@0.263.1/dist/umd/lucide-react.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow-x: hidden; }
  </style>
  <script>
    // localStorage Polyfill - replaces Claude's window.storage with standard browser localStorage
    window.storage = {
      async get(key) {
        try {
          const value = localStorage.getItem(key);
          return value ? { key, value, shared: false } : null;
        } catch (error) {
          console.error('Storage get error:', error);
          return null;
        }
      },
      async set(key, value) {
        try {
          localStorage.setItem(key, value);
          return { key, value, shared: false };
        } catch (error) {
          console.error('Storage set error:', error);
          return null;
        }
      },
      async delete(key) {
        try {
          localStorage.removeItem(key);
          return { key, deleted: true, shared: false };
        } catch (error) {
          console.error('Storage delete error:', error);
          return null;
        }
      },
      async list(prefix) {
        try {
          const keys = [];
          for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (!prefix || key.startsWith(prefix)) {
              keys.push(key);
            }
          }
          return { keys, prefix, shared: false };
        } catch (error) {
          console.error('Storage list error:', error);
          return { keys: [], shared: false };
        }
      }
    };
  </script>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    // ============================================================
    // PROJECT A HALL TRACKER - COMPLETE APPLICATION
    // Deployment-Ready Version with localStorage Support
    // ============================================================
    
    // NOTE: Due to artifact size limitations, this file needs the complete
    // component code from remixed-53bdf61a inserted here.
    
    // The working artifact contains ~4000 lines of production code.
    // To complete this file:
    // 1. Copy ALL code from the remixed-53bdf61a artifact
    // 2. Paste it here (replacing this comment block)
    // 3. Save and deploy to Vercel
    
    // Everything else is ready:
    // ‚úÖ localStorage polyfill configured
    // ‚úÖ All CDN dependencies loaded
    // ‚úÖ React, Recharts, Lucide ready
    // ‚úÖ Tailwind CSS ready
    
    const { useState } = React;

import React, { useState, useEffect, useMemo, useCallback } from 'react';
import { Plus, ChevronDown, ChevronUp, Save, Download, Upload, Database, Sun, Moon } from 'lucide-react';
import { LineChart, Line, BarChart, Bar, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts';

// MACHINE REGISTRY ARCHITECTURE
// ============================================================
// This registry is the SINGLE SOURCE OF TRUTH for all machines.
// All code must access machines through this registry by ID only.
// Machine IDs are PERMANENT and can NEVER be reused or changed.

// MACHINE REGISTRY ARCHITECTURE
// ============================================================
// This registry is the SINGLE SOURCE OF TRUTH for all machines.
// All code must access machines through this registry by ID only.
// Machine IDs are PERMANENT and can NEVER be reused or changed.
//
// CRITICAL: Do NOT use ALL_MACHINES or any hardcoded machine lists!
// ALWAYS use one of these:
// - registry.getActive() - All active machines (system + user)
// - registry.getSystem() - System machines only
// - registry.getUser() - User-defined machines only
// - MACHINES (component state) - Filtered active machines with Hanabi logic
//
// The popularity system and ALL machine operations depend on using
// the registry correctly. Using stale references will break features.

const SYSTEM_MACHINES = [];

// Machine Registry Class
class MachineRegistry {
  constructor() {
    this.systemMachines = new Map();
    this.userMachines = new Map();
    this.inactiveMachines = new Map(); // For deleted machines that still exist in history
    
    // Initialize system machines
    SYSTEM_MACHINES.forEach(machine => {
      this.systemMachines.set(machine.id, { ...machine });
    });
  }
  
  // Get a machine by ID (checks all sources)
  getById(id) {
    return this.systemMachines.get(id) || 
           this.userMachines.get(id) || 
           this.inactiveMachines.get(id) || 
           null;
  }
  
  // Get all active machines (system + active user machines)
  getActive() {
    return [
      ...Array.from(this.systemMachines.values()),
      ...Array.from(this.userMachines.values())
    ];
  }
  
  // Get only system machines
  getSystem() {
    return Array.from(this.systemMachines.values());
  }
  
  // Get only user-defined machines
  getUser() {
    return Array.from(this.userMachines.values());
  }
  
  // Get inactive/deleted machines (for historical data resolution)
  getInactive() {
    return Array.from(this.inactiveMachines.values());
  }
  
  // Add a user-defined machine
  addUserMachine(machine) {
    if (!machine.id || !machine.name) {
      throw new Error('Machine must have id and name');
    }
    
    // Check for ID conflicts
    if (this.systemMachines.has(machine.id)) {
      throw new Error(`Machine ID "${machine.id}" conflicts with system machine`);
    }
    
    if (this.userMachines.has(machine.id)) {
      throw new Error(`Machine ID "${machine.id}" already exists`);
    }
    
    if (this.inactiveMachines.has(machine.id)) {
      throw new Error(`Machine ID "${machine.id}" was previously used and cannot be reused`);
    }
    
    // Add user machine with defaults
    const newMachine = {
      id: machine.id,
      name: machine.name,
      allowedOdds: machine.allowedOdds || [2, 5, 6],
      neverAllowed: machine.neverAllowed || [1],
      initial: machine.initial || 2,
      isSystem: false,
      isUser: true,
      addedAt: new Date().toISOString()
    };
    
    this.userMachines.set(machine.id, newMachine);
    return newMachine;
  }
  
  // Update a user-defined machine (ID cannot change)
  updateUserMachine(id, updates) {
    const machine = this.userMachines.get(id);
    if (!machine) {
      throw new Error(`User machine "${id}" not found`);
    }
    
    // Prevent ID changes
    if (updates.id && updates.id !== id) {
      throw new Error('Machine ID cannot be changed');
    }
    
    // Prevent system flag changes
    delete updates.isSystem;
    delete updates.isUser;
    
    const updated = { ...machine, ...updates };
    this.userMachines.set(id, updated);
    return updated;
  }
  
  // Deactivate a user-defined machine (soft delete - preserves history)
  deactivateUserMachine(id) {
    const machine = this.userMachines.get(id);
    if (!machine) {
      throw new Error(`User machine "${id}" not found`);
    }
    
    // Move to inactive
    this.inactiveMachines.set(id, { 
      ...machine, 
      isActive: false,
      deactivatedAt: new Date().toISOString() 
    });
    
    this.userMachines.delete(id);
    return true;
  }
  
  // Reactivate a previously deactivated machine
  reactivateUserMachine(id) {
    const machine = this.inactiveMachines.get(id);
    if (!machine) {
      throw new Error(`Inactive machine "${id}" not found`);
    }
    
    // Move back to active
    const reactivated = { ...machine, isActive: true };
    delete reactivated.deactivatedAt;
    
    this.userMachines.set(id, reactivated);
    this.inactiveMachines.delete(id);
    return reactivated;
  }
  
  // Load user machines from storage
  loadUserMachines(userMachinesData) {
    if (!userMachinesData) return;
    
    const { active = [], inactive = [] } = userMachinesData;
    
    // Load active user machines
    active.forEach(machine => {
      // Skip if conflicts with system
      if (!this.systemMachines.has(machine.id)) {
        this.userMachines.set(machine.id, { ...machine, isUser: true });
      }
    });
    
    // Load inactive machines (for historical data)
    inactive.forEach(machine => {
      if (!this.systemMachines.has(machine.id) && !this.userMachines.has(machine.id)) {
        this.inactiveMachines.set(machine.id, { ...machine, isUser: true, isActive: false });
      }
    });
  }
  
  // Serialize for storage
  serialize() {
    return {
      active: Array.from(this.userMachines.values()),
      inactive: Array.from(this.inactiveMachines.values())
    };
  }
}

// Global registry instance (will be initialized in component)
let machineRegistry = new MachineRegistry();

const GRAPHS = ['Gradual climb', 'Slow bleed', 'Spike + flat', 'Sawtooth', 'Cliff drop', 'Dead flat'];

function App() {
  // Machine Registry State
  const [registry, setRegistry] = useState(() => new MachineRegistry());
  
  const [currentCycle, setCurrentCycle] = useState(1);
  const [currentWeek, setCurrentWeek] = useState(1);
  const [allCycles, setAllCycles] = useState([1]);
  const [stats, setStats] = useState({});
  const [settings, setSettings] = useState({});
  const [adjustments, setAdjustments] = useState({});
  const [designatedLosers, setDesignatedLosers] = useState({});
  const [expandedMachine, setExpandedMachine] = useState(null);
  const [activeTab, setActiveTab] = useState('stats');
  const [availableMachines, setAvailableMachines] = useState([]);
  const [machinePopularity, setMachinePopularity] = useState({});
  const [lastRollTime, setLastRollTime] = useState(null);
  const [generalNotes, setGeneralNotes] = useState({});
  const [retiredMachines, setRetiredMachines] = useState({});
  const [procedures, setProcedures] = useState('');
  // OPTIMIZED: Two-tier time system
  // - displayTime: Updates every second for smooth UI clock display
  // - currentTime: Updates every 10 seconds for business logic (sufficient for hall operations)
  // This reduces re-renders from 60/sec to 6/sec while keeping UI responsive
  const [currentTime, setCurrentTime] = useState(new Date());
  const [displayTime, setDisplayTime] = useState(new Date()); // Separate state for UI clock
  const [accumulatedInputs, setAccumulatedInputs] = useState({});
  const [isNightMode, setIsNightMode] = useState(false);
  const [fileInputKey, setFileInputKey] = useState(0);
  const [currentAvailableCount, setCurrentAvailableCount] = useState(null);
  const [allTimeStats, setAllTimeStats] = useState({});
  const [calendarYear, setCalendarYear] = useState(new Date().getFullYear());
  const [calendarMonth, setCalendarMonth] = useState(new Date().getMonth());
  const [selectedDate, setSelectedDate] = useState(null);
  const [calendarNotes, setCalendarNotes] = useState({});
  const [customPromotions, setCustomPromotions] = useState([]);
  const [calendarStats, setCalendarStats] = useState({});
  const [trafficHistory, setTrafficHistory] = useState([]);
  const [dailyTrafficGraphs, setDailyTrafficGraphs] = useState({});
  const [dailyStats, setDailyStats] = useState({});
  const [weeklyStats, setWeeklyStats] = useState({});
  const [promoName, setPromoName] = useState('');
  const [promoDetails, setPromoDetails] = useState('');
  const [promoRules, setPromoRules] = useState('');
  const [showRestoreOptions, setShowRestoreOptions] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const [registryVersion, setRegistryVersion] = useState(0);
  const [hallName, setHallName] = useState('Project A Hall Tracker');
  const [showNameEditor, setShowNameEditor] = useState(false);
  const [tempHallName, setTempHallName] = useState('');
  const [monthlyExportHidden, setMonthlyExportHidden] = useState({});
  const [restoreOptions, setRestoreOptions] = useState({
    stats: true,
    settings: true,
    adjustments: true,
    designatedLosers: true,
    cycles: true,
    machinePopularity: true,
    generalNotes: true,
    retiredMachines: true,
    procedures: true,
    machinesIAmPlaying: true,
    calendarNotes: true,
    customPromotions: true,
    calendarStats: true,
    dailyTrafficGraphs: true,
    allTimeStats: true,
    preDeterminedDays: true,
    currentDayPlan: true,
    dayPlanLoaded: true,
    activeHanabiVariant: true,
    userMachines: true,
    hallName: true,
    monthlyExportHidden: true
  });

  const [showResetConfirm, setShowResetConfirm] = useState(false);

  const [lastManualRollDate, setLastManualRollDate] = useState(null);
  const [nextAutoRollTime, setNextAutoRollTime] = useState(null);
  const [machineAvailabilityCount, setMachineAvailabilityCount] = useState({});
  const [preDeterminedDays, setPreDeterminedDays] = useState({});
  const [currentDayPlan, setCurrentDayPlan] = useState(null);
  const [dayPlanLoaded, setDayPlanLoaded] = useState(false);
  const [tomorrowPlanGenerated, setTomorrowPlanGenerated] = useState(false);
  const [activeHanabiVariant, setActiveHanabiVariant] = useState('hanabi'); // 'hanabi' or 'hanabiMatte'

  const [retireWeeksState, setRetireWeeksState] = useState({});
  const [lastHanabiCheckMonday, setLastHanabiCheckMonday] = useState(null);
  const [nextHanabiSwapWeeks, setNextHanabiSwapWeeks] = useState(null);
  const [hanabiSwapMessage, setHanabiSwapMessage] = useState(null);
  
  // Track when popularity was last updated
  const [popularityLastUpdated, setPopularityLastUpdated] = useState(null);
  const [popularityRefreshStatus, setPopularityRefreshStatus] = useState('');
  
  // Track if we've already handled today's midnight transition
  const [midnightTransitionHandled, setMidnightTransitionHandled] = useState(false);

  // Machine Management UI State
  const [machineFormMode, setMachineFormMode] = useState('add'); // 'add' or 'edit'
  const [editingMachineId, setEditingMachineId] = useState(null);
  const [machineForm, setMachineForm] = useState({
    id: '',
    name: '',
    allowedOdds: [2, 5, 6],
    neverAllowed: [1],
    initial: 2
  });

  // Filter machines based on active Hanabi variant
  // REGISTRY: Use registry.getActive() instead of ALL_MACHINES
  const MACHINES = useMemo(() => {
    const activeMachines = registry.getActive();
    return activeMachines.filter(m => {
      if (m.id === 'hanabi' || m.id === 'hanabiMatte') {
        return m.id === activeHanabiVariant;
      }
      return true;
    });
  }, [registry, registryVersion, activeHanabiVariant]);

  const isMachineRetired = useCallback((machineId) => {
    const retirement = retiredMachines[machineId];
    if (!retirement) return false;
    
    const now = new Date(currentTime);
    const returnDate = new Date(retirement.returnDate);
    
    const today = new Date(now);
    today.setHours(0, 0, 0, 0);
    
    const returnDay = new Date(returnDate);
    returnDay.setHours(0, 0, 0, 0);
    
    return today < returnDay;
  }, [retiredMachines, currentTime]);

  const generateHolidays = () => {
    const holidays = [];
    const getNthWeekday = (year, month, weekday, n) => {
      const firstDay = new Date(year, month, 1);
      const offset = (weekday - firstDay.getDay() + 7) % 7;
      return new Date(year, month, 1 + offset + (n - 1) * 7);
    };
    
    for (let year = 2025; year <= 2075; year++) {
      // Fixed date holidays
      holidays.push(
        { name: "New Year's Day", start: new Date(year, 0, 1), end: new Date(year, 0, 1) },
        { name: "National Foundation Day", start: new Date(year, 1, 11), end: new Date(year, 1, 11) },
        { name: "Emperor's Birthday", start: new Date(year, 1, 23), end: new Date(year, 1, 23) },
        { name: "Showa Day", start: new Date(year, 3, 29), end: new Date(year, 3, 29) },
        { name: "Constitution Day", start: new Date(year, 4, 3), end: new Date(year, 4, 3) },
        { name: "Greenery Day", start: new Date(year, 4, 4), end: new Date(year, 4, 4) },
        { name: "Children's Day", start: new Date(year, 4, 5), end: new Date(year, 4, 5) },
        { name: "Mountain Day", start: new Date(year, 7, 11), end: new Date(year, 7, 11) },
        { name: "Culture Day", start: new Date(year, 10, 3), end: new Date(year, 10, 3) },
        { name: "Labor Thanksgiving Day", start: new Date(year, 10, 23), end: new Date(year, 10, 23) }
      );
      
      // Floating holidays (nth weekday of month)
      holidays.push(
        { name: "Coming-of-Age Day", start: getNthWeekday(year, 0, 1, 2), end: getNthWeekday(year, 0, 1, 2) },
        { name: "Marine Day", start: getNthWeekday(year, 6, 1, 3), end: getNthWeekday(year, 6, 1, 3) },
        { name: "Respect for the Aged Day", start: getNthWeekday(year, 8, 1, 3), end: getNthWeekday(year, 8, 1, 3) },
        { name: "Sports Day", start: getNthWeekday(year, 9, 1, 2), end: getNthWeekday(year, 9, 1, 2) }
      );
      
      // Equinox days (calculated)
      const vernalEquinox = new Date(year, 2, Math.floor(20.8431 + 0.242194 * (year - 1980) - Math.floor((year - 1980) / 4)));
      holidays.push({ name: "Vernal Equinox Day", start: vernalEquinox, end: vernalEquinox });
      
      const autumnalEquinox = new Date(year, 8, Math.floor(23.2488 + 0.242194 * (year - 1980) - Math.floor((year - 1980) / 4)));
      holidays.push({ name: "Autumnal Equinox Day", start: autumnalEquinox, end: autumnalEquinox });
      
      // Golden Week
      holidays.push({ name: "Golden Week", start: new Date(year, 4, 3), end: new Date(year, 4, 5) });
      
      // Silver Week (conditional)
      const respectDay = getNthWeekday(year, 8, 1, 3);
      if (autumnalEquinox.getDate() - respectDay.getDate() === 2) {
        holidays.push({ name: "Silver Week", start: respectDay, end: autumnalEquinox });
      }
    }
    
    return holidays;
  };
  
  const japaneseHolidays = generateHolidays();

  const getCurrentHoliday = useCallback(() => {
    const today = new Date(currentTime);
    today.setHours(0, 0, 0, 0);
    return japaneseHolidays.find(holiday => {
      const start = new Date(holiday.start);
      const end = new Date(holiday.end);
      start.setHours(0, 0, 0, 0);
      end.setHours(23, 59, 59, 999);
      return today >= start && today <= end;
    });
  }, [currentTime, japaneseHolidays]);

  const checkHanabiSwapOnMonday = async () => {
    const now = new Date(currentTime);
    const dayOfWeek = now.getDay();
    
    // Only check on Mondays (day 1)
    if (dayOfWeek !== 1) return;
    
    const mondayKey = `${now.getFullYear()}-${now.getMonth()}-${now.getDate()}`;
    
    // Check if we already processed this Monday
    if (lastHanabiCheckMonday === mondayKey) return;
    
    console.log('üé∞ Checking Hanabi swap on Monday...');
    
    // If we have a countdown, decrement it
    if (nextHanabiSwapWeeks !== null && nextHanabiSwapWeeks > 0) {
      const newWeeks = nextHanabiSwapWeeks - 1;
      setNextHanabiSwapWeeks(newWeeks);
      setLastHanabiCheckMonday(mondayKey);
      
      try {
        await window.storage.set('parlour-next-hanabi-swap', newWeeks.toString());
        await window.storage.set('parlour-last-hanabi-check', mondayKey);
      } catch (error) {
        console.error('Error saving Hanabi countdown:', error);
      }
      
      console.log(`‚è≥ ${newWeeks} week(s) until next Hanabi swap check`);
      return;
    }
    
    // We're ready to check for a swap
    const swapRoll = Math.random();
    const swapChance = 0.025; // 2.5% chance
    
    if (swapRoll < swapChance) {
      // SWAP HAPPENS!
      setIsLoading(true);
      
      const oldVariant = activeHanabiVariant;
      const newVariant = oldVariant === 'hanabi' ? 'hanabiMatte' : 'hanabi';
      
      // Perform the swap
      setActiveHanabiVariant(newVariant);
      
      // Set a random cooldown period (1-4 weeks)
      const cooldownWeeks = Math.floor(Math.random() * 4) + 1;
      setNextHanabiSwapWeeks(cooldownWeeks);
      setLastHanabiCheckMonday(mondayKey);
      
      // Set swap message
      const message = newVariant === 'hanabi' 
        ? 'üé∞ Original Panel Hanabi is now on the floor!'
        : '‚ú® Special Edition Matte Black Panel Hanabi is now on the floor!';
      
      setHanabiSwapMessage(message);
      
      // Save to storage
      try {
        await window.storage.set('parlour-active-hanabi', newVariant);
        await window.storage.set('parlour-next-hanabi-swap', cooldownWeeks.toString());
        await window.storage.set('parlour-last-hanabi-check', mondayKey);
      } catch (error) {
        console.error('Error saving Hanabi swap:', error);
      }
      
      // Hide loading after a moment
      setTimeout(() => {
        setIsLoading(false);
        
        // Auto-dismiss message after 10 seconds
        setTimeout(() => {
          setHanabiSwapMessage(null);
        }, 10000);
      }, 1500);
      
    } else {
      // No swap, set a random cooldown period (1-4 weeks)
      const cooldownWeeks = Math.floor(Math.random() * 4) + 1;
      setNextHanabiSwapWeeks(cooldownWeeks);
      setLastHanabiCheckMonday(mondayKey);
      
      try {
        await window.storage.set('parlour-next-hanabi-swap', cooldownWeeks.toString());
        await window.storage.set('parlour-last-hanabi-check', mondayKey);
      } catch (error) {
        console.error('Error saving Hanabi check:', error);
      }
    }
  };

  useEffect(() => {
    if (selectedDate) {
      const existingPromo = customPromotions.find(p => {
        const promoDate = new Date(p.date);
        return promoDate.getFullYear() === selectedDate.getFullYear() &&
               promoDate.getMonth() === selectedDate.getMonth() &&
               promoDate.getDate() === selectedDate.getDate();
      });
      
      if (existingPromo) {
        setPromoName(existingPromo.name || '');
        setPromoDetails(existingPromo.details || '');
        setPromoRules(existingPromo.rules || '');
      } else {
        setPromoName('');
        setPromoDetails('');
        setPromoRules('');
      }
    }
  }, [selectedDate, customPromotions]);

  // CRITICAL: Initialize machines IMMEDIATELY on mount if hall is open
  useEffect(() => {
    const initializeMachines = async () => {
      console.log('üöÄ initializeMachines - Starting initialization');
      const now = new Date(currentTime);
      const hallCurrentlyOpen = isHallOpen();
      
      console.log('üöÄ Hall open?', hallCurrentlyOpen);
      
      if (hallCurrentlyOpen) {
        const dateKey = `${now.getFullYear()}-${now.getMonth()}-${now.getDate()}`;
        console.log('üöÄ Date key:', dateKey);
        
        // Check if plan exists for today in storage
        let storedPlans = {};
        try {
          const plansData = await window.storage.get('parlour-predetermined-days');
          if (plansData) {
            storedPlans = JSON.parse(plansData.value);
            console.log('üöÄ Loaded stored plans, keys:', Object.keys(storedPlans));
          }
        } catch (error) {
          console.error('Error loading stored plans:', error);
        }
        
        let plan = storedPlans[dateKey];
        
        // LOCK MECHANISM: If plan exists in storage, ALWAYS use it - never regenerate
        if (plan) {
          console.log('üîí Plan LOCKED for today - using stored plan (no regeneration)');
          
          // Update state with the locked plan
          setPreDeterminedDays(storedPlans);
          setCurrentDayPlan(plan);
          setDayPlanLoaded(true);
          
          // Get current hour's machines and display them
          const currentHour = now.getHours();
          const currentHourPlan = plan.hourlySchedule.find(h => h.hour === currentHour);
          
          if (currentHourPlan) {
            console.log(`üé∞ Setting machines for hour ${currentHour}:`, currentHourPlan.availableMachines);
            setAvailableMachines(currentHourPlan.availableMachines);
            setCurrentAvailableCount(currentHourPlan.availableCount);
          } else {
            console.error('‚ùå No schedule found for current hour!');
          }
          
          // Mark transition as handled
          setMidnightTransitionHandled(true);
          try {
            await window.storage.set('parlour-last-transition-date', dateKey);
          } catch (error) {
            console.error('Error saving transition date:', error);
          }
          
          return; // Exit early - plan is locked
        }
        
        // No plan exists - generate NEW plan (only happens ONCE per day)
        console.log('üìÖ No plan for today - generating NEW plan (will be locked after this)');
        
        // CRITICAL: Wait for registry to be ready
        const activeMachines = registry.getActive();
        console.log('üé∞ Active machines available:', activeMachines.length, activeMachines.map(m => m.id));
        
        if (activeMachines.length === 0) {
          console.error('‚ùå No machines available in registry! Will retry when registry updates.');
          return;
        }
        
        // Generate plan inline to avoid circular dependency
        plan = generateDayPlan(now);
        console.log('‚úÖ Generated NEW plan, hourlySchedule length:', plan.hourlySchedule.length);
        
        // LOCK IT IN: Save to storage immediately
        storedPlans[dateKey] = plan;
        
        try {
          await window.storage.set('parlour-predetermined-days', JSON.stringify(storedPlans));
          console.log('üîí Plan LOCKED and saved to storage - will not regenerate on refresh');
        } catch (error) {
          console.error('‚ùå Error saving day plan:', error);
        }
        
        // Update state with the plan
        setPreDeterminedDays(storedPlans);
        setCurrentDayPlan(plan);
        setDayPlanLoaded(true);
        
        // Get current hour's machines and display them IMMEDIATELY
        const currentHour = now.getHours();
        const currentHourPlan = plan.hourlySchedule.find(h => h.hour === currentHour);
        
        if (currentHourPlan) {
          console.log(`üé∞ Setting machines for hour ${currentHour}:`, currentHourPlan.availableMachines);
          setAvailableMachines(currentHourPlan.availableMachines);
          setCurrentAvailableCount(currentHourPlan.availableCount);
        } else {
          console.error('‚ùå No schedule found for current hour!');
        }
        
        // Mark that we've handled the transition for this date
        setMidnightTransitionHandled(true);
        try {
          await window.storage.set('parlour-last-transition-date', dateKey);
        } catch (error) {
          console.error('Error saving transition date:', error);
        }
      }
    };
    
    initializeMachines();
  }, [registry, registryVersion, currentTime]); // Removed isHallOpen - just call it directly


  useEffect(() => {
    const checkAndSimulateMissedTime = async () => {
      try {
        const lastActiveData = await window.storage.get('parlour-last-active');
        const now = Date.now();
        
        if (lastActiveData) {
          const lastActive = parseInt(lastActiveData.value);
          const minutesSinceLastActive = Math.floor((now - lastActive) / (1000 * 60));
          
          if (minutesSinceLastActive >= 15) {
            await simulateMissedActivity(lastActive, now);
          }
        }
        
        await window.storage.set('parlour-last-active', now.toString());
      } catch (error) {
        console.error('Error checking missed time:', error);
      }
    };
    
    // Load data first, then check for missed time
    const initialize = async () => {
      await loadData();
      await checkAndSimulateMissedTime();
      await checkHanabiSwapOnMonday();
      
      // CRITICAL: Wait a tick for state updates to propagate
      await new Promise(resolve => setTimeout(resolve, 100));
      
      // After loading data, check if hall is open and initialize machines
      const now = new Date();
      const hallCurrentlyOpen = isHallOpen();
      
      console.log('üîç Initialize check - Hall open?', hallCurrentlyOpen);
      
      if (hallCurrentlyOpen) {
        const dateKey = `${now.getFullYear()}-${now.getMonth()}-${now.getDate()}`;
        
        // Check if plan exists for today in storage
        let storedPlans = {};
        try {
          const plansData = await window.storage.get('parlour-predetermined-days');
          if (plansData) {
            storedPlans = JSON.parse(plansData.value);
            console.log('üìã Loaded stored plans, keys:', Object.keys(storedPlans));
          }
        } catch (error) {
          console.error('Error loading stored plans:', error);
        }
        
        let plan = storedPlans[dateKey];
        
        if (!plan) {
          console.log('üìÖ No plan for today - generating new plan');
          plan = generateDayPlan(now);
          
          // Save to storage immediately
          storedPlans[dateKey] = plan;
          
          try {
            await window.storage.set('parlour-predetermined-days', JSON.stringify(storedPlans));
            console.log('‚úÖ Saved new day plan to storage');
          } catch (error) {
            console.error('‚ùå Error saving day plan:', error);
          }
        } else {
          console.log('üîí Found existing plan for today - using it');
        }
        
        // Update state with the plan
        setPreDeterminedDays(storedPlans);
        setCurrentDayPlan(plan);
        setDayPlanLoaded(true);
        
        // Get current hour's machines and display them IMMEDIATELY
        const currentHour = now.getHours();
        const currentHourPlan = plan.hourlySchedule.find(h => h.hour === currentHour);
        
        if (currentHourPlan) {
          console.log(`üé∞ Setting machines for hour ${currentHour}:`, currentHourPlan.availableMachines);
          setAvailableMachines(currentHourPlan.availableMachines);
          setCurrentAvailableCount(currentHourPlan.availableCount);
        } else {
          console.error('‚ùå No schedule found for current hour!');
        }
      }
    };
    
    initialize();
    
    // OPTIMIZED: Separate intervals for display vs logic
    // Display clock updates every second for smooth UI
    const displayClockInterval = setInterval(() => {
      setDisplayTime(new Date());
    }, 1000);
    
    // Logic updates every 10 seconds (sufficient for hall operations)
    const logicClockInterval = setInterval(() => {
      setCurrentTime(new Date());
    }, 10000); // 10 seconds instead of 1 second
    
    const activeInterval = setInterval(async () => {
      try {
        await window.storage.set('parlour-last-active', Date.now().toString());
      } catch (error) {
        console.error('Error updating last active time:', error);
      }
    }, 5 * 60 * 1000);
    
    return () => {
      clearInterval(displayClockInterval);
      clearInterval(logicClockInterval);
      clearInterval(activeInterval);
    };
  }, []);

  useEffect(() => {
    const month = currentTime.getMonth() + 1; // 1-12
    const day = currentTime.getDate();
    
    // Cycle is the month number
    const cycle = month;
    
    // Week is based on day of month
    let week = 1;
    if (day >= 8 && day < 15) week = 2;
    else if (day >= 15 && day < 22) week = 3;
    else if (day >= 22) week = 4;
    
    setCurrentCycle(cycle);
    setCurrentWeek(week);
    
    // Ensure all cycles up to current month exist
    const allMonths = Array.from({ length: 12 }, (_, i) => i + 1);
    setAllCycles(allMonths);
  }, [currentTime]);

  useEffect(() => {
    const hours = currentTime.getHours();
    setIsNightMode(hours >= 18 || hours < 6);
  }, [currentTime]);

  useEffect(() => {
    const checkRollInterval = setInterval(() => {
      const hallOpen = isHallOpen();
      const currentDate = new Date(currentTime);
      const currentHour = currentDate.getHours();
      const currentMinutes = currentDate.getMinutes();
      
      const todayKey = `${currentDate.getFullYear()}-${currentDate.getMonth()}-${currentDate.getDate()}`;
      
      // Check if we've already handled the transition for this date
      window.storage.get('parlour-last-transition-date').then(result => {
        const lastTransitionDate = result ? result.value : null;
        const alreadyHandled = lastTransitionDate === todayKey;
        
        // Generate new day plan at midnight (00:00-00:05 window) - only if not already handled
        if (currentHour === 0 && currentMinutes < 5 && !alreadyHandled) {
          console.log('üïõ MIDNIGHT TRANSITION - Generating new day plan for', todayKey);
          
          // Check if plan already exists in storage
          if (!preDeterminedDays[todayKey]) {
            const newPlan = generateDayPlan(currentDate);
            
            const updatedPlans = {
              ...preDeterminedDays,
              [todayKey]: newPlan
            };
            setPreDeterminedDays(updatedPlans);
            setCurrentDayPlan(newPlan);
            setDayPlanLoaded(true);
            
            // Immediately sync available machines to hour 0 of the new plan
            const hour0Plan = newPlan.hourlySchedule.find(h => h.hour === 0);
            if (hour0Plan) {
              console.log('‚úÖ Setting midnight machines:', hour0Plan.availableMachines);
              setAvailableMachines(hour0Plan.availableMachines);
              setCurrentAvailableCount(hour0Plan.availableCount);
            }
            
            // Save immediately
            window.storage.set('parlour-predetermined-days', JSON.stringify(updatedPlans))
              .catch(err => console.error('Error saving midnight plan:', err));
          } else {
            // Plan exists - just load it
            console.log('üîÑ Loading existing plan for midnight:', todayKey);
            const existingPlan = preDeterminedDays[todayKey];
            setCurrentDayPlan(existingPlan);
            setDayPlanLoaded(true);
            
            const hour0Plan = existingPlan.hourlySchedule.find(h => h.hour === 0);
            if (hour0Plan) {
              console.log('‚úÖ Setting midnight machines from existing plan:', hour0Plan.availableMachines);
              setAvailableMachines(hour0Plan.availableMachines);
              setCurrentAvailableCount(hour0Plan.availableCount);
            }
          }
          
          // Mark this date as handled
          setMidnightTransitionHandled(true);
          window.storage.set('parlour-last-transition-date', todayKey)
            .catch(err => console.error('Error saving transition date:', err));
        }
        
        // Reset the flag when it's no longer the midnight window
        if (currentHour !== 0 || currentMinutes >= 5) {
          if (alreadyHandled && midnightTransitionHandled) {
            // We're past the midnight window - ready for next midnight
            setMidnightTransitionHandled(false);
          }
        }
      }).catch(err => console.error('Error checking transition date:', err));
      
      // When hall closes at 11 PM, clean up
      if (!hallOpen) {
        if (availableMachines.length > 0) {
          setAvailableMachines([]);
          setLastRollTime(null);
        }
        
        // Save today's traffic graph when hall closes - MUST include final hour (22:00)
        const dateKey = `${currentDate.getFullYear()}-${currentDate.getMonth()}-${currentDate.getDate()}`;
        
        // Check if we already saved today's graph
        if (!dailyTrafficGraphs[dateKey] && currentDayPlan && dayPlanLoaded) {
          // Build complete traffic graph from day plan (all hours from open to 22:00)
          const trafficGraphData = currentDayPlan.hourlySchedule.map(hourPlan => ({
            hour: hourPlan.hour,
            availableCount: hourPlan.availableCount,
            occupiedCount: MACHINES.length - hourPlan.availableCount,
            occupancyRate: parseFloat(hourPlan.occupancyRate),
            timestamp: new Date(currentDate.getFullYear(), currentDate.getMonth(), currentDate.getDate(), hourPlan.hour, 0, 0).toISOString(),
            date: currentDate.toLocaleDateString()
          }));
          
          const updatedGraphs = { ...dailyTrafficGraphs, [dateKey]: trafficGraphData };
          setDailyTrafficGraphs(updatedGraphs);
          
          window.storage.set('parlour-daily-graphs', JSON.stringify(updatedGraphs)).catch(err => {
            console.error('Error saving daily graph:', err);
          });
        }
        
        // Reset day plan flags when hall closes
        if (dayPlanLoaded) {
          setDayPlanLoaded(false);
          setCurrentDayPlan(null);
        }
        
        return;
      }
      
      // Hall is open - use the pre-determined plan
      if (hallOpen && currentDayPlan && dayPlanLoaded) {
        const currentHourPlan = currentDayPlan.hourlySchedule.find(h => h.hour === currentHour);
        
        if (currentHourPlan) {
          // ALWAYS update available machines to match the plan for this hour
          // This ensures the displayed count matches the traffic indicator
          console.log(`üîÑ Updating machines for hour ${currentHour}:`, currentHourPlan.availableMachines);
          setAvailableMachines(currentHourPlan.availableMachines);
          setCurrentAvailableCount(currentHourPlan.availableCount);
          
          // Update machine availability heatmap
          const dateKey = `${currentDate.getFullYear()}-${currentDate.getMonth()}-${currentDate.getDate()}`;
          setMachineAvailabilityCount(prev => {
            const updated = { ...prev };
            if (!updated[dateKey]) {
              updated[dateKey] = {};
            }
            
            currentHourPlan.availableMachines.forEach(machineId => {
              const hourKey = `${machineId}-${currentHour}`;
              updated[dateKey][hourKey] = true;
            });
            
            return updated;
          });
        } else {
          console.error(`‚ùå No hour plan found for hour ${currentHour} in day plan`);
        }
      } else {
        if (hallOpen) {
          console.log('‚ö†Ô∏è Hall open but missing plan data:', {
            hasDayPlan: !!currentDayPlan,
            dayPlanLoaded,
            currentHour
          });
        }
      }
      
      // Check for machines that should be restored from retirement
      const now = new Date(currentTime);
      const isHallCurrentlyOpen = isHallOpen();
      
      // Only restore machines when hall is open
      if (isHallCurrentlyOpen) {
        Object.entries(retiredMachines).forEach(([machineId, retirement]) => {
          const returnDate = new Date(retirement.returnDate);
          
          const today = new Date(now);
          today.setHours(0, 0, 0, 0);
          const returnDay = new Date(returnDate);
          returnDay.setHours(0, 0, 0, 0);
          const shouldReturn = today >= returnDay;
          
          if (shouldReturn) {
            // Machine returns when hall opens on return date
            setRetiredMachines(prev => {
              const updated = { ...prev };
              delete updated[machineId];
              return updated;
            });
            
            const machine = registry.getById(machineId);
            alert(`${machine?.name} has returned from retirement.`);
          }
        });
      }
    }, 60000); // Check every minute
    
    return () => clearInterval(checkRollInterval);
  }, [currentTime, retiredMachines, currentDayPlan, dayPlanLoaded]);

  const loadData = async () => {
    setIsLoading(true);
    try {
      // OPTIMIZED: Try loading from batched storage first
      const batchedData = await window.storage.get('parlour-data');
      
      if (batchedData) {
        const data = JSON.parse(batchedData.value);
        
        // REGISTRY: Load user machines first (before any other data)
        if (data.userMachines) {
          const newRegistry = new MachineRegistry();
          newRegistry.loadUserMachines(data.userMachines);
          setRegistry(newRegistry);
          setRegistryVersion(prev => prev + 1); // Trigger registry update
          console.log('‚úÖ Loaded user machines:', newRegistry.serialize());
        }
        
        // Load all data from batched storage
        if (data.stats) setStats(data.stats);
        if (data.settings) setSettings(data.settings);
        if (data.adjustments) setAdjustments(data.adjustments);
        if (data.designatedLosers) setDesignatedLosers(data.designatedLosers);
        if (data.generalNotes) setGeneralNotes(data.generalNotes);
        if (data.retiredMachines) setRetiredMachines(data.retiredMachines);
        if (data.procedures) setProcedures(data.procedures);
        if (data.calendarNotes) setCalendarNotes(data.calendarNotes);
        if (data.customPromotions) setCustomPromotions(data.customPromotions);
        if (data.calendarStats) setCalendarStats(data.calendarStats);
        if (data.trafficHistory) setTrafficHistory(data.trafficHistory);
        if (data.dailyTrafficGraphs) setDailyTrafficGraphs(data.dailyTrafficGraphs);
        if (data.allTimeStats) setAllTimeStats(data.allTimeStats);
        if (data.lastManualRollDate) setLastManualRollDate(data.lastManualRollDate);
        if (data.nextAutoRollTime) setNextAutoRollTime(data.nextAutoRollTime);
        if (data.machineAvailabilityCount) setMachineAvailabilityCount(data.machineAvailabilityCount);
        if (data.preDeterminedDays) setPreDeterminedDays(data.preDeterminedDays);
        if (data.dailyStats) setDailyStats(data.dailyStats);
        if (data.weeklyStats) setWeeklyStats(data.weeklyStats);
        if (data.activeHanabiVariant) setActiveHanabiVariant(data.activeHanabiVariant);
        if (data.lastHanabiCheckMonday) setLastHanabiCheckMonday(data.lastHanabiCheckMonday);
        if (data.nextHanabiSwapWeeks !== undefined) setNextHanabiSwapWeeks(data.nextHanabiSwapWeeks);
        if (data.hallName) setHallName(data.hallName);
        if (data.monthlyExportHidden) setMonthlyExportHidden(data.monthlyExportHidden);
        
        // STEP 1: Load calendar stats first (needed for popularity calculation)
        let calStats = data.calendarStats || {};
        
        // STEP 2: Calculate popularity from calendar stats
        let calculatedPopularity = null;
        if (Object.keys(calStats).length > 0) {
          console.log('üìä Calculating popularity from calendar stats...');
          calculatedPopularity = calculatePopularityFromDaily(calStats);
          console.log('üìä Calculated popularity:', calculatedPopularity);
        }
        
        // STEP 3: Set popularity (calculated > saved > default)
        if (calculatedPopularity && Object.keys(calculatedPopularity).length > 0) {
          console.log('‚úÖ Using calculated popularity from calendar stats');
          setMachinePopularity(calculatedPopularity);
          
          // Find the date it was calculated from
          const sortedEntries = Object.entries(calStats)
            .filter(([_, entry]) => entry.popularity)
            .sort((a, b) => new Date(b[1].date) - new Date(a[1].date));
          
          if (sortedEntries.length > 0) {
            setPopularityLastUpdated(sortedEntries[0][1].popularityUpdated || sortedEntries[0][1].date);
          }
        } else if (data.machinePopularity) {
          console.log('üìä Using saved popularity (no calendar stats available)');
          setMachinePopularity(data.machinePopularity);
          setPopularityLastUpdated(data.popularityLastUpdated || null);
        } else {
          console.log('üìä No popularity data - initializing defaults');
          const initialPop = {};
          registry.getActive().forEach(m => {
            initialPop[m.id] = 0.5;
          });
          setMachinePopularity(initialPop);
        }
        
        if (data.allCycles) {
          setAllCycles(data.allCycles);
          if (data.allCycles.length > 0) setCurrentCycle(data.allCycles[data.allCycles.length - 1]);
        }
      } else {
        // FALLBACK: Load from individual storage keys (legacy support)
        const [
          statsData, settingsData, adjustmentsData, losersData, cyclesData,
          availableData, popularityData, notesData, retiredData, proceduresData,
          calendarNotesData, customPromoData, calendarStatsData,
          trafficHistoryData, dailyGraphsData, allTimeStatsData,
          lastManualRollData, nextAutoRollData, machineAvailabilityData,
          preDeterminedDaysData, dailyStatsData, weeklyStatsData, activeHanabiData,
          lastHanabiCheckData, nextHanabiSwapData, userMachinesData
        ] = await Promise.all([
          window.storage.get('parlour-stats'),
          window.storage.get('parlour-settings'),
          window.storage.get('parlour-adjustments'),
          window.storage.get('parlour-losers'),
          window.storage.get('parlour-cycles'),
          window.storage.get('parlour-available'),
          window.storage.get('parlour-popularity'),
          window.storage.get('parlour-notes'),
          window.storage.get('parlour-retired'),
          window.storage.get('parlour-procedures'),
          window.storage.get('parlour-calendar-notes'),
          window.storage.get('parlour-custom-promos'),
          window.storage.get('parlour-calendar-stats'),
          window.storage.get('parlour-traffic-history'),
          window.storage.get('parlour-daily-graphs'),
          window.storage.get('parlour-alltime-stats'),
          window.storage.get('parlour-last-manual-roll'),
          window.storage.get('parlour-next-auto-roll'),
          window.storage.get('parlour-machine-availability'),
          window.storage.get('parlour-predetermined-days'),
          window.storage.get('parlour-daily-stats'),
          window.storage.get('parlour-weekly-stats'),
          window.storage.get('parlour-active-hanabi'),
          window.storage.get('parlour-last-hanabi-check'),
          window.storage.get('parlour-next-hanabi-swap'),
          window.storage.get('parlour-user-machines')
        ]);

        // REGISTRY: Load user machines from separate storage key
        if (userMachinesData) {
          const newRegistry = new MachineRegistry();
          newRegistry.loadUserMachines(JSON.parse(userMachinesData.value));
          setRegistry(newRegistry);
          setRegistryVersion(prev => prev + 1); // Trigger registry update
          console.log('‚úÖ Loaded user machines from legacy storage');
        }

        if (statsData) setStats(JSON.parse(statsData.value));
        if (settingsData) setSettings(JSON.parse(settingsData.value));
        if (adjustmentsData) setAdjustments(JSON.parse(adjustmentsData.value));
        if (losersData) setDesignatedLosers(JSON.parse(losersData.value));
        if (notesData) setGeneralNotes(JSON.parse(notesData.value));
        if (retiredData) setRetiredMachines(JSON.parse(retiredData.value));
        if (proceduresData) setProcedures(proceduresData.value);
        if (calendarNotesData) setCalendarNotes(JSON.parse(calendarNotesData.value));
        if (customPromoData) setCustomPromotions(JSON.parse(customPromoData.value));
        if (trafficHistoryData) setTrafficHistory(JSON.parse(trafficHistoryData.value));
        if (dailyGraphsData) setDailyTrafficGraphs(JSON.parse(dailyGraphsData.value));
        if (allTimeStatsData) setAllTimeStats(JSON.parse(allTimeStatsData.value));
        if (lastManualRollData) setLastManualRollDate(lastManualRollData.value);
        if (nextAutoRollData) setNextAutoRollTime(parseInt(nextAutoRollData.value));
        if (machineAvailabilityData) setMachineAvailabilityCount(JSON.parse(machineAvailabilityData.value));
        if (preDeterminedDaysData) setPreDeterminedDays(JSON.parse(preDeterminedDaysData.value));
        if (dailyStatsData) setDailyStats(JSON.parse(dailyStatsData.value));
        if (weeklyStatsData) setWeeklyStats(JSON.parse(weeklyStatsData.value));
        if (activeHanabiData) setActiveHanabiVariant(activeHanabiData.value);
        if (lastHanabiCheckData) setLastHanabiCheckMonday(lastHanabiCheckData.value);
        if (nextHanabiSwapData) setNextHanabiSwapWeeks(parseInt(nextHanabiSwapData.value));
        
        // Load hall name
        const hallNameData = await window.storage.get('parlour-hall-name');
        if (hallNameData) setHallName(hallNameData.value);
        
        // Load monthly export hidden state
        const monthlyExportData = await window.storage.get('parlour-monthly-export-hidden');
        if (monthlyExportData) setMonthlyExportHidden(JSON.parse(monthlyExportData.value));
        
        // STEP 1: Load calendar stats
        let calStats = null;
        if (calendarStatsData) {
          calStats = JSON.parse(calendarStatsData.value);
          setCalendarStats(calStats);
        }
        
        // STEP 2: Calculate popularity from calendar stats
        let calculatedPopularity = null;
        if (calStats && Object.keys(calStats).length > 0) {
          console.log('üìä [LEGACY] Calculating popularity from calendar stats...');
          calculatedPopularity = calculatePopularityFromDaily(calStats);
        }
        
        // STEP 3: Set popularity (calculated > saved > default)
        if (calculatedPopularity && Object.keys(calculatedPopularity).length > 0) {
          console.log('‚úÖ [LEGACY] Using calculated popularity');
          setMachinePopularity(calculatedPopularity);
          
          const sortedEntries = Object.entries(calStats)
            .filter(([_, entry]) => entry.popularity)
            .sort((a, b) => new Date(b[1].date) - new Date(a[1].date));
          
          if (sortedEntries.length > 0) {
            setPopularityLastUpdated(sortedEntries[0][1].popularityUpdated || sortedEntries[0][1].date);
          }
        } else if (popularityData) {
          console.log('üìä [LEGACY] Using saved popularity');
          setMachinePopularity(JSON.parse(popularityData.value));
        } else {
          console.log('üìä [LEGACY] Initializing default popularity');
          const initialPop = {};
          registry.getActive().forEach(m => {
            initialPop[m.id] = 0.5;
          });
          setMachinePopularity(initialPop);
        }
        
        if (cyclesData) {
          const cycles = JSON.parse(cyclesData.value);
          setAllCycles(cycles);
          if (cycles.length > 0) setCurrentCycle(cycles[cycles.length - 1]);
        }
      }
    } catch (error) {
      console.log('No saved data found or error loading:', error);
      const initialPop = {};
      registry.getActive().forEach(m => {
        initialPop[m.id] = 0.5;
      });
      setMachinePopularity(initialPop);
    } finally {
      setIsLoading(false);
    }
  };

  const saveData = async () => {
    try {
      // OPTIMIZED: Batch all data into a single storage operation
      const allData = {
        stats,
        settings,
        adjustments,
        designatedLosers,
        allCycles,
        machinePopularity,
        popularityLastUpdated,
        generalNotes,
        retiredMachines,
        procedures,
        calendarNotes,
        customPromotions,
        calendarStats,
        trafficHistory,
        dailyTrafficGraphs,
        allTimeStats,
        machineAvailabilityCount,
        preDeterminedDays,
        dailyStats,
        weeklyStats,
        activeHanabiVariant,
        lastManualRollDate,
        nextAutoRollTime,
        lastHanabiCheckMonday,
        nextHanabiSwapWeeks,
        userMachines: registry.serialize(),
        hallName,
        monthlyExportHidden,
        version: '5.2', // Updated version
        lastSaved: new Date().toISOString()
      };
      
      await window.storage.set('parlour-data', JSON.stringify(allData));
      alert('Data saved successfully!');
    } catch (error) {
      alert('Error saving data: ' + error.message);
    }
  };

  const exportData = async () => {
    try {
      console.log('Starting operational report export...');
      
      // Use array for efficient string building
      const lines = [];
      
      lines.push('‚ïê'.repeat(80));
      lines.push('PACHISLOT HALL OPERATIONAL REPORT');
      lines.push('‚ïê'.repeat(80));
      lines.push('');
      lines.push(`Generated: ${new Date().toLocaleString()}`);
      lines.push(`Period: Cycle ${currentCycle}, Week ${currentWeek} | ${formatCurrentDateTime().date}`);
      lines.push(`Hall Status: ${getHallStatus().statusText} | Traffic: ${getHallStatus().trafficText}`);
      lines.push('');
      
      console.log('Header created successfully');

    // EXECUTIVE SUMMARY
    lines.push('‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê');
    lines.push('‚îÇ EXECUTIVE SUMMARY - TODAY\'S PERFORMANCE                                     ‚îÇ');
    lines.push('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò');
    lines.push('');
    
    const todayTotals = calculateAllTotals();
    const allTimeTotals = (() => {
      const totals = { totalPlays: 0, medalsIn: 0, medalsOut: 0, bbCount: 0, rbCount: 0 };
      MACHINES.forEach(machine => {
        totals.totalPlays += allTimeStats[`${machine.id}-totalPlays`] || 0;
        totals.medalsIn += allTimeStats[`${machine.id}-medalsIn`] || 0;
        totals.medalsOut += allTimeStats[`${machine.id}-medalsOut`] || 0;
        totals.bbCount += allTimeStats[`${machine.id}-bbCount`] || 0;
        totals.rbCount += allTimeStats[`${machine.id}-rbCount`] || 0;
      });
      const payout = totals.medalsIn > 0 ? ((totals.medalsOut / totals.medalsIn) * 100).toFixed(1) : 0;
      return { ...totals, payout };
    })();
    
    lines.push('TODAY\'S TOTALS:');
    lines.push(`  Total Plays: ${formatNumber(todayTotals.totalPlays)} plays`);
    lines.push(`  Medals In: ${formatNumber(todayTotals.medalsIn)}`);
    lines.push(`  Medals Out: ${formatNumber(todayTotals.medalsOut)}`);
    lines.push(`  Payout Rate: ${todayTotals.payout}%`);
    lines.push(`  Big Bonus: ${formatNumber(todayTotals.bbCount)} hits | Regular Bonus: ${formatNumber(todayTotals.rbCount)} hits`);
    lines.push('');
    
    lines.push('LIFETIME TOTALS (All Time):');
    lines.push(`  Total Plays: ${formatNumber(allTimeTotals.totalPlays)} plays`);
    lines.push(`  Overall Payout: ${allTimeTotals.payout}%`);
    lines.push(`  Total BBs: ${formatNumber(allTimeTotals.bbCount)} | Total RBs: ${formatNumber(allTimeTotals.rbCount)}`);
    lines.push('');
    
    // Top 3 Most Popular Machines
    const sortedByPop = [...MACHINES].sort((a, b) => {
      const popA = machinePopularity[a.id] || 0.50;
      const popB = machinePopularity[b.id] || 0.50;
      const normalizedA = popA > 1 ? popA / 100 : popA;
      const normalizedB = popB > 1 ? popB / 100 : popB;
      return normalizedB - normalizedA;
    });
    
    lines.push('TOP 3 MOST POPULAR MACHINES:');
    sortedByPop.slice(0, 3).forEach((machine, idx) => {
      const pop = machinePopularity[machine.id] || 0.50;
      const percentage = Math.round((pop > 1 ? pop / 100 : pop) * 100);
      lines.push(`  ${idx + 1}. ${machine.name} - ${percentage}% popularity`);
    });
    lines.push('');
    
    // Hot & Cold Machines (based on today's plays)
    const hotMachines = MACHINES.filter(m => {
      const plays = getStat(m.id, 'totalPlays');
      return plays > 0;
    }).sort((a, b) => getStat(b.id, 'totalPlays') - getStat(a.id, 'totalPlays')).slice(0, 3);
    
    const coldMachines = MACHINES.filter(m => {
      const plays = getStat(m.id, 'totalPlays');
      return plays === 0 || plays < 100;
    }).slice(0, 3);
    
    if (hotMachines.length > 0) {
      lines.push('üî• HOT MACHINES (Most Plays Today):');
      hotMachines.forEach(m => {
        const plays = getStat(m.id, 'totalPlays');
        lines.push(`  ‚Ä¢ ${m.name}: ${formatNumber(plays)} plays`);
      });
      lines.push('');
    }
    
    if (coldMachines.length > 0) {
      lines.push('‚ùÑÔ∏è  COLD MACHINES (Low Activity Today):');
      coldMachines.forEach(m => {
        const plays = getStat(m.id, 'totalPlays');
        lines.push(`  ‚Ä¢ ${m.name}: ${formatNumber(plays)} plays`);
      });
      lines.push('');
    }
    
    console.log('Executive summary complete');

    // HOURLY TRAFFIC SUMMARY
    lines.push('‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê');
    lines.push('‚îÇ HOURLY TRAFFIC SUMMARY                                                      ‚îÇ');
    lines.push('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò');
    lines.push('');
    
    if (currentDayPlan && dayPlanLoaded) {
      const now = new Date(currentTime);
      const currentHour = now.getHours();
      const pastHours = currentDayPlan.hourlySchedule.filter(h => h.hour <= currentHour);
      
      if (pastHours.length > 0) {
        // Group hours into periods
        const periods = [
          { name: 'Early Morning (0-6)', hours: pastHours.filter(h => h.hour >= 0 && h.hour < 6) },
          { name: 'Morning (6-11)', hours: pastHours.filter(h => h.hour >= 6 && h.hour < 11) },
          { name: 'Lunch Rush (11-13)', hours: pastHours.filter(h => h.hour >= 11 && h.hour < 13) },
          { name: 'Afternoon (13-18)', hours: pastHours.filter(h => h.hour >= 13 && h.hour < 18) },
          { name: 'Evening Rush (18-22)', hours: pastHours.filter(h => h.hour >= 18 && h.hour < 22) },
          { name: 'Late Night (22-24)', hours: pastHours.filter(h => h.hour >= 22) }
        ];
        
        periods.forEach(period => {
          if (period.hours.length > 0) {
            const avgAvailable = (period.hours.reduce((sum, h) => sum + h.availableCount, 0) / period.hours.length).toFixed(1);
            const avgOccupancy = (period.hours.reduce((sum, h) => sum + parseFloat(h.occupancyRate), 0) / period.hours.length).toFixed(1);
            const minAvailable = Math.min(...period.hours.map(h => h.availableCount));
            const maxAvailable = Math.max(...period.hours.map(h => h.availableCount));
            
            lines.push(`${period.name}:`);
            lines.push(`  Avg Available: ${avgAvailable} machines | Avg Occupancy: ${avgOccupancy}%`);
            lines.push(`  Range: ${minAvailable}-${maxAvailable} machines available`);
            
            // Check for special events
            const eventsInPeriod = period.hours.filter(h => h.hiddenEvent);
            if (eventsInPeriod.length > 0) {
              lines.push(`  ‚ö†Ô∏è  Special Events: ${eventsInPeriod.length} hidden luck events occurred`);
            }
            lines.push('');
          }
        });
        
        // Peak hour analysis
        const peakHour = pastHours.reduce((max, h) => 
          parseFloat(h.occupancyRate) > parseFloat(max.occupancyRate) ? h : max
        );
        const quietHour = pastHours.reduce((min, h) => 
          parseFloat(h.occupancyRate) < parseFloat(min.occupancyRate) ? h : min
        );
        
        lines.push('KEY OBSERVATIONS:');
        lines.push(`  üî• Peak Hour: ${peakHour.hour}:00 (${peakHour.occupancyRate}% occupancy, ${peakHour.availableCount} machines)`);
        lines.push(`  üìâ Quietest Hour: ${quietHour.hour}:00 (${quietHour.occupancyRate}% occupancy, ${quietHour.availableCount} machines)`);
        lines.push('');
      } else {
        lines.push('No hourly data available yet for today.');
        lines.push('');
      }
    } else {
      lines.push('Hall traffic monitoring not active yet.');
      lines.push('');
    }
    
    console.log('Hourly traffic summary complete');

    // MACHINE PERFORMANCE TABLE
    lines.push('‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê');
    lines.push('‚îÇ MACHINE PERFORMANCE SUMMARY (TODAY)                                         ‚îÇ');
    lines.push('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò');
    lines.push('');
    
    // Table header
    lines.push('Machine Name               Plays    Medals In  Medals Out  Payout%  BB   RB   Pop%  Status');
    lines.push('‚îÄ'.repeat(88));
    
    MACHINES.forEach(machine => {
      const plays = getStat(machine.id, 'totalPlays');
      const medalsIn = getStat(machine.id, 'medalsIn');
      const medalsOut = getStat(machine.id, 'medalsOut');
      const payout = medalsIn > 0 ? ((medalsOut / medalsIn) * 100).toFixed(1) : '0.0';
      const bb = getStat(machine.id, 'bbCount');
      const rb = getStat(machine.id, 'rbCount');
      const pop = machinePopularity[machine.id] || 0.50;
      const popPercent = Math.round((pop > 1 ? pop / 100 : pop) * 100);
      
      const isRetired = isMachineRetired(machine.id);
      const status = isRetired ? 'RETIRED' : 
                     plays === 0 ? 'IDLE' :
                     plays > 500 ? 'ACTIVE' : 'LOW';
      
      // Status indicator
      const statusSymbol = isRetired ? 'üîß' :
                          plays === 0 ? '‚ö™' :
                          plays > 500 ? 'üü¢' : 'üü°';
      
      // Format the row with proper spacing
      const namePad = machine.name.padEnd(25).substring(0, 25);
      const playsPad = formatNumber(plays).padStart(8);
      const inPad = formatNumber(medalsIn).padStart(11);
      const outPad = formatNumber(medalsOut).padStart(11);
      const payoutPad = payout.padStart(7);
      const bbPad = formatNumber(bb).padStart(4);
      const rbPad = formatNumber(rb).padStart(4);
      const popPad = popPercent.toString().padStart(4);
      
      lines.push(`${namePad} ${playsPad} ${inPad} ${outPad} ${payoutPad}% ${bbPad} ${rbPad} ${popPad}% ${statusSymbol} ${status}`);
    });
    lines.push('');
    
    // Performance indicators legend
    lines.push('STATUS LEGEND:');
    lines.push('  üü¢ ACTIVE (500+ plays) | üü° LOW (<500 plays) | ‚ö™ IDLE (0 plays) | üîß RETIRED');
    lines.push('');
    
    console.log('Machine performance table complete');

    // MACHINE ALERTS & RECOMMENDATIONS
    lines.push('‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê');
    lines.push('‚îÇ ALERTS & RECOMMENDATIONS                                                    ‚îÇ');
    lines.push('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò');
    lines.push('');
    
    let hasAlerts = false;
    
    // High payout machines (>110%)
    const highPayoutMachines = MACHINES.filter(m => {
      const medalsIn = getStat(m.id, 'medalsIn');
      const medalsOut = getStat(m.id, 'medalsOut');
      const plays = getStat(m.id, 'totalPlays');
      if (plays === 0 || medalsIn === 0) return false;
      const payout = (medalsOut / medalsIn) * 100;
      return payout > 110;
    });
    
    if (highPayoutMachines.length > 0) {
      hasAlerts = true;
      lines.push('‚ö†Ô∏è  HIGH PAYOUT ALERT (>110%):');
      highPayoutMachines.forEach(m => {
        const medalsIn = getStat(m.id, 'medalsIn');
        const medalsOut = getStat(m.id, 'medalsOut');
        const payout = ((medalsOut / medalsIn) * 100).toFixed(1);
        lines.push(`  ‚Ä¢ ${m.name}: ${payout}% payout - Consider adjusting odds`);
      });
      lines.push('');
    }
    
    // Low payout machines (<80%)
    const lowPayoutMachines = MACHINES.filter(m => {
      const medalsIn = getStat(m.id, 'medalsIn');
      const medalsOut = getStat(m.id, 'medalsOut');
      const plays = getStat(m.id, 'totalPlays');
      if (plays === 0 || medalsIn === 0) return false;
      const payout = (medalsOut / medalsIn) * 100;
      return payout < 80 && plays > 200;
    });
    
    if (lowPayoutMachines.length > 0) {
      hasAlerts = true;
      lines.push('üìâ LOW PAYOUT MACHINES (<80%):');
      lowPayoutMachines.forEach(m => {
        const medalsIn = getStat(m.id, 'medalsIn');
        const medalsOut = getStat(m.id, 'medalsOut');
        const payout = ((medalsOut / medalsIn) * 100).toFixed(1);
        lines.push(`  ‚Ä¢ ${m.name}: ${payout}% payout - May discourage play`);
      });
      lines.push('');
    }
    
    // Underperforming popular machines
    const underperformingPopular = MACHINES.filter(m => {
      const pop = machinePopularity[m.id] || 0.50;
      const popPercent = (pop > 1 ? pop / 100 : pop) * 100;
      const plays = getStat(m.id, 'totalPlays');
      return popPercent > 60 && plays < 300;
    });
    
    if (underperformingPopular.length > 0) {
      hasAlerts = true;
      lines.push('üéØ POPULAR BUT LOW ACTIVITY:');
      underperformingPopular.forEach(m => {
        const pop = machinePopularity[m.id] || 0.50;
        const popPercent = Math.round((pop > 1 ? pop / 100 : pop) * 100);
        const plays = getStat(m.id, 'totalPlays');
        lines.push(`  ‚Ä¢ ${m.name}: ${popPercent}% popularity but only ${formatNumber(plays)} plays`);
      });
      lines.push('');
    }
    
    // Retired machines status
    const retiredList = Object.entries(retiredMachines || {}).filter(([id]) => {
      try {
        return isMachineRetired(id);
      } catch (err) {
        return false;
      }
    });
    
    if (retiredList.length > 0) {
      hasAlerts = true;
      lines.push('üîß MACHINES IN RETIREMENT:');
      retiredList.forEach(([machineId]) => {
        try {
          const machine = MACHINES.find(m => m.id === machineId);
          const info = getRetirementInfo(machineId);
          if (machine && info && info.returnDate) {
            lines.push(`  ‚Ä¢ ${machine.name} - Returns in ${info.daysRemaining} day(s) (${info.returnDate.toLocaleDateString()})`);
          }
        } catch (err) {
          // Skip if error
        }
      });
      lines.push('');
    }
    
    if (!hasAlerts) {
      lines.push('‚úì No alerts - All machines operating within normal parameters');
      lines.push('');
    }
    
    console.log('Alerts and recommendations complete');

    // DETAILED MACHINE PROFILES (condensed)
    lines.push('‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê');
    lines.push('‚îÇ DETAILED MACHINE PROFILES                                                   ‚îÇ');
    lines.push('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò');
    lines.push('');
    
    MACHINES.forEach(machine => {
      const plays = getStat(machine.id, 'totalPlays');
      
      // Only show detailed profiles for machines with activity
      if (plays > 0) {
        const machTotals = calculateTotals(machine.id);
        const isRetired = isMachineRetired(machine.id);
        const setting = getSetting(machine.id);
        const pop = machinePopularity[machine.id] || 0.50;
        const popPercent = Math.round((pop > 1 ? pop / 100 : pop) * 100);
        
        lines.push(`${machine.name}`);
        lines.push('‚îÄ'.repeat(40));
        
        if (isRetired) {
          const retirementInfo = getRetirementInfo(machine.id);
          lines.push(`STATUS: üîß RETIRED until ${retirementInfo?.returnDate?.toLocaleDateString() || 'Unknown'}`);
        } else {
          lines.push(`STATUS: ‚úì ACTIVE | Setting: ${setting} | Popularity: ${popPercent}%`);
        }
        
        lines.push(`Plays: ${formatNumber(plays)} | Medals In: ${formatNumber(machTotals.medalsIn)} | Out: ${formatNumber(machTotals.medalsOut)}`);
        lines.push(`Payout: ${machTotals.payout}% | BB: ${formatNumber(getStat(machine.id, 'bbCount'))} | RB: ${formatNumber(getStat(machine.id, 'rbCount'))}`);
        
        // Show all-time stats if significantly different
        const allTimePlays = allTimeStats[`${machine.id}-totalPlays`] || 0;
        if (allTimePlays > plays * 2) {
          const allTimeIn = allTimeStats[`${machine.id}-medalsIn`] || 0;
          const allTimeOut = allTimeStats[`${machine.id}-medalsOut`] || 0;
          const allTimePayout = allTimeIn > 0 ? ((allTimeOut / allTimeIn) * 100).toFixed(1) : '0.0';
          lines.push(`Lifetime: ${formatNumber(allTimePlays)} plays | ${allTimePayout}% payout`);
        }
        
        const graph = getAdjustment(machine.id, 'graph');
        const notes = getAdjustment(machine.id, 'notes');
        
        if (graph) lines.push(`Pattern: ${graph}`);
        if (notes) lines.push(`Notes: ${notes}`);
        
        lines.push('');
      }
    });
    
    console.log('Detailed machine profiles complete');

    // QUICK REFERENCE FOOTER
    lines.push('‚ïê'.repeat(80));
    lines.push('QUICK REFERENCE');
    lines.push('‚ïê'.repeat(80));
    lines.push('');
    lines.push('SYSTEM INFO:');
    lines.push(`  Active Machines: ${activeMachinesCount} | Retired: ${retiredList.length}`);
    lines.push(`  Custom Promotions: ${customPromotions?.length || 0}`);
    lines.push(`  Traffic Data Points: ${trafficHistory?.length || 0}`);
    lines.push('');
    
    // Current holiday
    const currentHoliday = getCurrentHoliday();
    if (currentHoliday) {
      lines.push('CURRENT HOLIDAY:');
      lines.push(`  ${currentHoliday.name}`);
      lines.push(`  ${new Date(currentHoliday.start).toLocaleDateString()} - ${new Date(currentHoliday.end).toLocaleDateString()}`);
      lines.push('');
    }
    
    // Floor analysis
    const loser = designatedLosers[getPeriodKey()];
    if (loser) {
      const loserMachine = MACHINES.find(m => m.id === loser);
      lines.push('FLOOR ANALYSIS:');
      lines.push(`  Designated Loser: ${loserMachine?.name || 'Unknown'}`);
      lines.push('');
    }
    
    lines.push('‚ïê'.repeat(80));
    lines.push('END OF OPERATIONAL REPORT');
    lines.push('‚ïê'.repeat(80));

    console.log('Creating blob...');
    const exportText = lines.join('\n');
    const blob = new Blob([exportText], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `parlour-report-${new Date().toISOString().split('T')[0]}.txt`;
    document.body.appendChild(a);
    console.log('Triggering download...');
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    console.log('Export completed successfully!');
    alert('Operational Report exported successfully!\n\nThis condensed report focuses on:\n‚Ä¢ Executive summary\n‚Ä¢ Hourly traffic analysis\n‚Ä¢ Machine performance table\n‚Ä¢ Alerts & recommendations\n‚Ä¢ Key observations');
  } catch (error) {
    console.error('Export error:', error);
    alert('Error exporting report: ' + error.message);
  }
};

  const backupData = () => {
    try {
      const backup = {
        version: '5.3',
        exportDate: new Date().toISOString(),
        systemInfo: {
          totalMachines: MACHINES.length,
          activeMachines: MACHINES.filter(m => !isMachineRetired(m.id)).length,
          retiredMachines: Object.keys(retiredMachines).filter(id => isMachineRetired(id)).length,
          userDefinedMachines: registry.getUser().length,
          totalCycles: allCycles.length,
          currentCycle,
          currentWeek,
          customPromotions: customPromotions.length,
          preDeterminedDays: Object.keys(preDeterminedDays).length,
          dayPlanLoaded: dayPlanLoaded,
          calendarStatsSnapshots: Object.keys(calendarStats || {}).length,
          activeHanabiVariant: activeHanabiVariant,
          hallName: hallName
        },
        data: {
          // Period-based stats
          stats, 
          settings, 
          adjustments, 
          designatedLosers,
          allCycles, 
          currentCycle, 
          currentWeek,
          
          // Machine data
          machinePopularity,
          popularityLastUpdated,
          retiredMachines,
          userMachines: registry.serialize(),
          
          // Notes and procedures
          generalNotes, 
          procedures,
          calendarNotes,
          customPromotions, 
          calendarStats,
          
          // Traffic data (simplified - only daily graphs)
          dailyTrafficGraphs,
          
          // All-time cumulative stats
          allTimeStats,
          
          // Pre-determined day plans
          preDeterminedDays,
          currentDayPlan,
          dayPlanLoaded,
          
          // Timing and Hanabi data
          lastManualRollDate,
          nextAutoRollTime,
          activeHanabiVariant,
          lastHanabiCheckMonday,
          nextHanabiSwapWeeks,
          
          // Hall customization
          hallName,
          monthlyExportHidden
        }
      };

      const blob = new Blob([JSON.stringify(backup, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `parlour-backup-${new Date().toISOString().split('T')[0]}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      alert('JSON backup downloaded successfully!\n\nVersion 5.3 - Complete backup including:\n‚Ä¢ Day plan lock system\n‚Ä¢ User-defined machines\n‚Ä¢ Hanabi swap system\n‚Ä¢ Calendar stats with popularity\n‚Ä¢ Hall customization');
    } catch (error) {
      console.error('Backup error:', error);
      alert('Error creating backup: ' + error.message);
    }
  };

  const loadBackup = (event) => {
    const file = event.target.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = (e) => {
      try {
        const backup = JSON.parse(e.target.result);
        
        if (!backup.version || !backup.data) {
          alert('Invalid backup format');
          return;
        }

        setShowRestoreOptions(true);
        window.pendingBackup = backup;
        
      } catch (error) {
        alert('Error loading backup: ' + error.message);
      }
    };
    
    reader.readAsText(file);
    event.target.value = '';
    setFileInputKey(prev => prev + 1);
  };

  const confirmRestore = async () => {
    setIsLoading(true);
    setShowRestoreOptions(false);
    
    try {
      const backup = window.pendingBackup;
      if (!backup) {
        setIsLoading(false);
        return;
      }
      
      const data = backup.data;
      
      // Only restore checked items
      if (restoreOptions.stats) {
        setStats(data.stats || {});
        await window.storage.set('parlour-stats', JSON.stringify(data.stats || {}));
      }
      
      if (restoreOptions.settings) {
        setSettings(data.settings || {});
        await window.storage.set('parlour-settings', JSON.stringify(data.settings || {}));
      }
      
      if (restoreOptions.adjustments) {
        setAdjustments(data.adjustments || {});
        await window.storage.set('parlour-adjustments', JSON.stringify(data.adjustments || {}));
      }
      
      if (restoreOptions.designatedLosers) {
        setDesignatedLosers(data.designatedLosers || {});
        await window.storage.set('parlour-losers', JSON.stringify(data.designatedLosers || {}));
      }
      
      if (restoreOptions.cycles) {
        setAllCycles(data.allCycles || [1]);
        setCurrentCycle(data.currentCycle || 1);
        setCurrentWeek(data.currentWeek || 1);
        await window.storage.set('parlour-cycles', JSON.stringify(data.allCycles || [1]));
      }
      
      // REGISTRY: Restore user machines if selected
      if (restoreOptions.userMachines && data.userMachines) {
        const newRegistry = new MachineRegistry();
        newRegistry.loadUserMachines(data.userMachines);
        setRegistry(newRegistry);
        console.log('‚úÖ Restored user machines:', newRegistry.serialize());
      }
      
      if (restoreOptions.machinePopularity) {
        setMachinePopularity(data.machinePopularity || {});
        await window.storage.set('parlour-popularity', JSON.stringify(data.machinePopularity || {}));
      }
      
      if (restoreOptions.generalNotes) {
        setGeneralNotes(data.generalNotes || {});
        await window.storage.set('parlour-notes', JSON.stringify(data.generalNotes || {}));
      }
      
      if (restoreOptions.retiredMachines) {
        setRetiredMachines(data.retiredMachines || {});
        await window.storage.set('parlour-retired', JSON.stringify(data.retiredMachines || {}));
      }
      
      if (restoreOptions.procedures) {
        setProcedures(data.procedures || '');
        await window.storage.set('parlour-procedures', data.procedures || '');
      }
      
      if (restoreOptions.calendarNotes) {
        setCalendarNotes(data.calendarNotes || {});
        await window.storage.set('parlour-calendar-notes', JSON.stringify(data.calendarNotes || {}));
      }
      
      if (restoreOptions.customPromotions) {
        setCustomPromotions(data.customPromotions || []);
        await window.storage.set('parlour-custom-promos', JSON.stringify(data.customPromotions || []));
      }
      
      if (restoreOptions.calendarStats) {
        setCalendarStats(data.calendarStats || {});
        await window.storage.set('parlour-calendar-stats', JSON.stringify(data.calendarStats || {}));
      }
      
      if (restoreOptions.dailyTrafficGraphs && data.dailyTrafficGraphs) {
        setDailyTrafficGraphs(data.dailyTrafficGraphs || {});
        await window.storage.set('parlour-daily-graphs', JSON.stringify(data.dailyTrafficGraphs || {}));
      }
      
      if (restoreOptions.allTimeStats && data.allTimeStats) {
        setAllTimeStats(data.allTimeStats || {});
        await window.storage.set('parlour-alltime-stats', JSON.stringify(data.allTimeStats || {}));
      }
      
      // Restore pre-determined days system
      if (restoreOptions.preDeterminedDays && data.preDeterminedDays) {
        setPreDeterminedDays(data.preDeterminedDays || {});
        await window.storage.set('parlour-predetermined-days', JSON.stringify(data.preDeterminedDays || {}));
      }
      
      if (restoreOptions.currentDayPlan && data.currentDayPlan) {
        setCurrentDayPlan(data.currentDayPlan);
      }
      
      if (restoreOptions.dayPlanLoaded && data.dayPlanLoaded !== undefined) {
        setDayPlanLoaded(data.dayPlanLoaded);
      }
      
      if (restoreOptions.activeHanabiVariant && data.activeHanabiVariant) {
        setActiveHanabiVariant(data.activeHanabiVariant);
        await window.storage.set('parlour-active-hanabi', data.activeHanabiVariant);
      }
      
      if (data.lastHanabiCheckMonday && restoreOptions.activeHanabiVariant) {
        setLastHanabiCheckMonday(data.lastHanabiCheckMonday);
        await window.storage.set('parlour-last-hanabi-check', data.lastHanabiCheckMonday);
      }
      
      if (data.nextHanabiSwapWeeks !== undefined && restoreOptions.activeHanabiVariant) {
        setNextHanabiSwapWeeks(data.nextHanabiSwapWeeks);
        await window.storage.set('parlour-next-hanabi-swap', data.nextHanabiSwapWeeks.toString());
      }
      
      if (data.popularityLastUpdated && restoreOptions.machinePopularity) {
        setPopularityLastUpdated(data.popularityLastUpdated);
      }
      
      if (data.lastManualRollDate && restoreOptions.cycles) {
        setLastManualRollDate(data.lastManualRollDate);
        await window.storage.set('parlour-last-manual-roll', data.lastManualRollDate);
      }
      
      if (data.nextAutoRollTime && restoreOptions.cycles) {
        setNextAutoRollTime(data.nextAutoRollTime);
        await window.storage.set('parlour-next-auto-roll', data.nextAutoRollTime.toString());
      }
      
      if (restoreOptions.hallName && data.hallName) {
        setHallName(data.hallName);
        await window.storage.set('parlour-hall-name', data.hallName);
      }
      
      if (restoreOptions.monthlyExportHidden && data.monthlyExportHidden) {
        setMonthlyExportHidden(data.monthlyExportHidden);
        await window.storage.set('parlour-monthly-export-hidden', JSON.stringify(data.monthlyExportHidden));
      }
      
      window.pendingBackup = null;
      
      const restoredItems = Object.entries(restoreOptions)
        .filter(([key, value]) => value)
        .map(([key]) => key)
        .join(', ');
      
      setIsLoading(false);
      alert(`Backup restored successfully!\n\nRestored: ${restoredItems}`);
    } catch (error) {
      setIsLoading(false);
      alert('Error restoring backup: ' + error.message);
    }
  };

  const resetAllData = async () => {
    setIsLoading(true);
    setShowResetConfirm(false);
    
    try {
      // Reset all state to defaults
      setStats({});
      setSettings({});
      setAdjustments({});
      setDesignatedLosers({});
      setRetiredMachines({});
      setCalendarNotes({});
      setCustomPromotions([]);
      setCalendarStats({});
      setDailyTrafficGraphs({});
      setMachineAvailabilityCount({});
      setPreDeterminedDays({});
      setCurrentDayPlan(null);
      setDayPlanLoaded(false);
      
      // REGISTRY: Reset to system machines only (preserve user machines if they exist)
      // User can choose to keep or clear user machines separately
      const newRegistry = new MachineRegistry();
      setRegistry(newRegistry);
      setRegistryVersion(prev => prev + 1);
      
      // Reset popularity to default 0.5 (50%) - NEW FORMAT
      const defaultPopularity = {};
      newRegistry.getActive().forEach(m => {
        defaultPopularity[m.id] = 0.5;  // Raw score 0.5 = 50%
      });
      setMachinePopularity(defaultPopularity);
      
      // Clear all storage
      await window.storage.set('parlour-stats', JSON.stringify({}));
      await window.storage.set('parlour-settings', JSON.stringify({}));
      await window.storage.set('parlour-adjustments', JSON.stringify({}));
      await window.storage.set('parlour-losers', JSON.stringify({}));
      await window.storage.set('parlour-retired', JSON.stringify({}));
      await window.storage.set('parlour-calendar-notes', JSON.stringify({}));
      await window.storage.set('parlour-custom-promos', JSON.stringify([]));
      await window.storage.set('parlour-calendar-stats', JSON.stringify({}));
      await window.storage.set('parlour-daily-graphs', JSON.stringify({}));
      await window.storage.set('parlour-machine-availability', JSON.stringify({}));
      await window.storage.set('parlour-popularity', JSON.stringify(defaultPopularity));
      await window.storage.set('parlour-predetermined-days', JSON.stringify({}));
      // Note: User machines are NOT cleared - they persist across resets
      
      setIsLoading(false);
      alert('‚úì All data has been reset to default!\n\n‚ö†Ô∏è IMPORTANT: Popularity format has been updated to new daily algorithm format (0.0-1.0).\n\nAll machines now at 0.50 (50%) popularity.\n\nThe following have been cleared:\n‚Ä¢ Machine Stats\n‚Ä¢ Settings\n‚Ä¢ Adjustments\n‚Ä¢ Designated Losers\n‚Ä¢ Retired Machines\n‚Ä¢ Calendar Notes\n‚Ä¢ Custom Promotions\n‚Ä¢ Calendar Stats\n‚Ä¢ Traffic Graphs\n‚Ä¢ Machine Popularity (reset to 0.50)\n‚Ä¢ Pre-determined Day Plans\n\n‚úÖ User-defined machines were preserved');
    } catch (error) {
      setIsLoading(false);
      alert('Error resetting data: ' + error.message);
    }
  };

  const generateDayPlan = useCallback((targetDate) => {
    console.log('üé≤ generateDayPlan called for:', targetDate.toISOString());
    
    // CRITICAL FIX: Get fresh active machines at generation time
    const freshActiveMachines = registry.getActive().filter(m => {
      // Apply Hanabi filtering
      if (m.id === 'hanabi' || m.id === 'hanabiMatte') {
        return m.id === activeHanabiVariant;
      }
      return true;
    });
    
    console.log('üé∞ Fresh active machines:', freshActiveMachines.length, freshActiveMachines.map(m => m.id));
    
    const dayOfWeek = targetDate.getDay();
    const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
    
    // 24/7 operation - all hours
    const openHour = 0;
    const closeHour = 24;
    
    // Check for holidays
    const holiday = japaneseHolidays.find(h => {
      const start = new Date(h.start);
      const end = new Date(h.end);
      start.setHours(0, 0, 0, 0);
      end.setHours(23, 59, 59, 999);
      const checkDate = new Date(targetDate);
      checkDate.setHours(0, 0, 0, 0);
      return checkDate >= start && checkDate <= end;
    });
    
    const isPeakPeriod = holiday?.name.includes('Golden Week') || holiday?.name.includes('Silver Week');
    
    // Hidden luck system - determines if micro-events will occur during the day
    const hiddenLuckRoll = Math.random();
    let hiddenDayType = 'neutral'; // Default: no special events
    let hiddenLuckIcon = '';
    
    if (hiddenLuckRoll < 0.05) {
      // 5% chance for a good luck day (friendly hall)
      hiddenDayType = 'good';
      hiddenLuckIcon = 'üçÄ';
    } else if (hiddenLuckRoll < 0.10) {
      // 5% chance for a bad luck day (hostile hall)
      hiddenDayType = 'bad';
      hiddenLuckIcon = 'üôÖ';
    }
    // Remaining 90% = neutral (no icon, normal behavior)
    
    const hourlySchedule = [];
    const activeMachines = freshActiveMachines.filter(m => !isMachineRetired(m.id));
    console.log('‚úÖ Active machines after filtering retired:', activeMachines.length, activeMachines.map(m => m.id));
    
    for (let hour = openHour; hour < closeHour; hour++) {
      // Calculate base available count
      let baseCount;
      
      if (hour < 11) {
        baseCount = isWeekend ? 6 : 5;
      } else if (hour >= 11 && hour < 13) {
        baseCount = 3;
      } else if (isWeekend && hour >= 13 && hour < 22) {
        baseCount = 2;
      } else if (!isWeekend && hour >= 18 && hour < 22) {
        baseCount = 2;
      } else if (hour >= 22) {
        baseCount = 4;
      } else {
        baseCount = 4;
      }
      
      // Apply holiday adjustments
      if (isPeakPeriod) {
        baseCount = Math.max(1, baseCount - 2);
      } else if (holiday) {
        baseCount = Math.max(1, baseCount - 1);
      }
      
      // Add random micro-variations
      const random = Math.random();
      if (baseCount === 1) {
        if (random < 0.12) baseCount = 2;
        else if (random < 0.15) baseCount = 3;
      } else if (baseCount === 2) {
        if (random < 0.18) baseCount = 3;
        else if (random < 0.25) baseCount = 4;
        else if (random < 0.35) baseCount = 1;
      } else if (baseCount >= 3) {
        if (random < 0.22) baseCount = Math.min(7, baseCount + 1);
        else if (random < 0.45) baseCount = Math.max(1, baseCount - 1);
      }
      
      let finalCount = Math.max(1, Math.min(7, baseCount));
      
      // Apply hidden luck system micro-events
      let hiddenEventOccurred = false;
      let hiddenEventType = '';
      
      if (hiddenDayType === 'good' && finalCount < 6) {
        // Good luck day: Chance to add machines (make hall friendlier)
        const majorRoll = Math.random();
        if (majorRoll < 0.01) {
          // 1% chance to add 1-2 machines
          const addAmount = Math.random() < 0.5 ? 1 : 2;
          finalCount = Math.min(7, finalCount + addAmount);
          hiddenEventOccurred = true;
          hiddenEventType = `good_major_+${addAmount}`;
        } else if (majorRoll < 0.06) {
          // 5% chance to add 1 machine
          finalCount = Math.min(7, finalCount + 1);
          hiddenEventOccurred = true;
          hiddenEventType = 'good_minor_+1';
        }
      } else if (hiddenDayType === 'bad' && finalCount > 1) {
        // Bad luck day: Chance to remove machines (make hall hostile)
        const majorRoll = Math.random();
        if (majorRoll < 0.01) {
          // 1% chance to remove 1-2 machines
          const removeAmount = Math.random() < 0.5 ? 1 : 2;
          finalCount = Math.max(1, finalCount - removeAmount);
          hiddenEventOccurred = true;
          hiddenEventType = `bad_major_-${removeAmount}`;
        } else if (majorRoll < 0.06) {
          // 5% chance to remove 1 machine
          finalCount = Math.max(1, finalCount - 1);
          hiddenEventOccurred = true;
          hiddenEventType = 'bad_minor_-1';
        }
      }
      
      // Select which machines are available this hour
      const availableThisHour = [];
      const machinePool = activeMachines.map(m => {
        const rawScore = machinePopularity[m.id] || 0.50;
        let weight = 150 - (rawScore * 100);
        
        // On good luck days, boost unpopular machines (friendlier selection)
        // On bad luck days, boost popular machines (hostile - they're always taken)
        if (hiddenDayType === 'good') {
          // Make unpopular machines MORE likely to appear
          if (rawScore < 0.40) {
            weight = weight * 1.5; // 50% boost for unpopular machines
          }
        } else if (hiddenDayType === 'bad') {
          // Make popular machines LESS likely to appear (they're occupied)
          if (rawScore > 0.60) {
            weight = weight * 0.5; // 50% reduction for popular machines
          }
        }
        
        return {
          id: m.id,
          popularity: rawScore,
          weight: weight
        };
      });
      
      console.log(`‚öôÔ∏è Hour ${hour}: machinePool length = ${machinePool.length}, finalCount = ${finalCount}`);
      
      while (availableThisHour.length < Math.min(finalCount, activeMachines.length)) {
        const remaining = machinePool.filter(m => !availableThisHour.includes(m.id));
        
        if (remaining.length === 0) {
          console.log(`‚ö†Ô∏è Hour ${hour}: No more machines to select, breaking`);
          break;
        }
        
        const totalWeight = remaining.reduce((sum, m) => sum + m.weight, 0);
        
        if (totalWeight === 0) {
          // Fallback: just add a random remaining machine
          const randomMachine = remaining[Math.floor(Math.random() * remaining.length)];
          availableThisHour.push(randomMachine.id);
          console.log(`‚ö†Ô∏è Hour ${hour}: Zero weight, adding random machine ${randomMachine.id}`);
          continue;
        }
        
        let randomWeight = Math.random() * totalWeight;
        let selectedMachine = null;
        
        for (let machine of remaining) {
          randomWeight -= machine.weight;
          if (randomWeight <= 0) {
            selectedMachine = machine;
            break;
          }
        }
        
        if (selectedMachine) {
          availableThisHour.push(selectedMachine.id);
        } else {
          // Fallback: add first remaining machine
          availableThisHour.push(remaining[0].id);
          console.log(`‚ö†Ô∏è Hour ${hour}: No selection, adding fallback ${remaining[0].id}`);
        }
      }
      
      console.log(`‚úÖ Hour ${hour}: Selected ${availableThisHour.length} machines:`, availableThisHour);
      
      hourlySchedule.push({
        hour,
        availableCount: finalCount,
        availableMachines: availableThisHour,
        occupancyRate: ((MACHINES.length - finalCount) / MACHINES.length * 100).toFixed(1),
        hiddenEvent: hiddenEventOccurred ? hiddenEventType : null
      });
    }
    
    return {
      date: targetDate.toISOString(),
      dayOfWeek,
      isWeekend,
      holiday: holiday?.name || null,
      isPeakPeriod,
      hiddenDayType,
      hiddenLuckIcon,
      generatedAt: new Date().toISOString(),
      hourlySchedule
    };
  }, [japaneseHolidays, machinePopularity, isMachineRetired, registry, registryVersion, activeHanabiVariant]);

  const saveDayPlan = useCallback(async (dayPlan) => {
    try {
      const dateKey = `${new Date(dayPlan.date).getFullYear()}-${new Date(dayPlan.date).getMonth()}-${new Date(dayPlan.date).getDate()}`;
      const updatedPlans = {
        ...preDeterminedDays,
        [dateKey]: dayPlan
      };
      setPreDeterminedDays(updatedPlans);
      await window.storage.set('parlour-predetermined-days', JSON.stringify(updatedPlans));
      return true;
    } catch (error) {
      console.error('‚ùå Error saving day plan:', error);
      return false;
    }
  }, [preDeterminedDays]);


  const autoRollMachines = async () => {
    const activeMachines = MACHINES.filter(machine => 
      !isMachineRetired(machine.id)
    );
    
    const fluctuatedCount = calculateFluctuatedCount();
    setCurrentAvailableCount(fluctuatedCount);
    
    if (activeMachines.length < fluctuatedCount) {
      setAvailableMachines([]);
      scheduleNextAutoRoll();
      return;
    }
    
    const available = [];
    const machinePool = activeMachines.map(m => {
      // Get popularity from state (which is calculated from Daily Stats Algorithm)
      const rawScore = machinePopularity[m.id] || 0.50;
      
      // Inverse weight: lower popularity = higher availability chance
      // Convert raw score (0.0-1.0) to weight
      let weight = 150 - (rawScore * 100);
      
      const percentage = Math.round(rawScore * 100);
      
      if (percentage >= 70 && Math.random() < 0.01) {
        weight = weight * 3;
        console.log(`üé∞ RARE EVENT: ${m.name} (${percentage}% popularity) has become available!`);
      } else if (percentage >= 60 && Math.random() < 0.015) {
        weight = weight * 2;
        console.log(`üé≤ Uncommon event: ${m.name} (${percentage}% popularity) available`);
      }
      
      return {
        id: m.id,
        popularity: rawScore,
        weight: weight
      };
    });
    
    const previouslyAvailable = availableMachines.filter(id => 
      activeMachines.some(m => m.id === id)
    );
    previouslyAvailable.forEach(machineId => {
      if (Math.random() < 0.4 && available.length < fluctuatedCount) {
        available.push(machineId);
      }
    });
    
    while (available.length < fluctuatedCount && machinePool.length > 0) {
      const totalWeight = machinePool.reduce((sum, m) => {
        return available.includes(m.id) ? sum : sum + m.weight;
      }, 0);
      
      let random = Math.random() * totalWeight;
      let selectedMachine = null;
      
      for (let machine of machinePool) {
        if (available.includes(machine.id)) continue;
        random -= machine.weight;
        if (random <= 0) {
          selectedMachine = machine;
          break;
        }
      }
      
      if (selectedMachine) {
        available.push(selectedMachine.id);
      } else {
        const remaining = machinePool.filter(m => !available.includes(m.id));
        if (remaining.length > 0) {
          available.push(remaining[Math.floor(Math.random() * remaining.length)].id);
        }
      }
    }
    
    setAvailableMachines(available);
    setLastRollTime(Date.now());
    
    // Update machine availability count for today
    const now = new Date(currentTime);
    const todayKey = `${now.getFullYear()}-${now.getMonth()}-${now.getDate()}`;
    setMachineAvailabilityCount(prev => {
      const todayCount = prev[todayKey] || {};
      available.forEach(machineId => {
        todayCount[machineId] = (todayCount[machineId] || 0) + 1;
      });
      return {
        ...prev,
        [todayKey]: todayCount
      };
    });
    
    scheduleNextAutoRoll();
  };

  const simulateMissedActivity = async (startTime, endTime) => {
    const newTrafficEntries = [];
    const newAvailabilityCounts = { ...machineAvailabilityCount };
    
    let currentSimTime = startTime;
    
    while (currentSimTime < endTime) {
      const simDate = new Date(currentSimTime);
      const hours = simDate.getHours();
      const day = simDate.getDay();
      
      // Check if hall was open at this time
      const wasHallOpen = (day >= 1 && day <= 5 && hours >= 8 && hours < 23) || 
                          ((day === 6 || day === 0) && hours >= 7 && hours < 23);
      
      if (wasHallOpen) {
        // Calculate fluctuated count for this time
        const isWeekend = day === 0 || day === 6;
        let baseCount;
        
        if (hours < 11) {
          baseCount = isWeekend ? 6 : 5;
        } else if (hours >= 11 && hours < 13) {
          baseCount = 3;
        } else if (isWeekend && hours >= 13 && hours < 22) {
          baseCount = 2;
        } else if (!isWeekend && hours >= 18 && hours < 22) {
          baseCount = 2;
        } else if (hours >= 22) {
          baseCount = 4;
        } else {
          baseCount = 4;
        }
        
        // Add some randomness
        const random = Math.random();
        if (baseCount === 1) {
          if (random < 0.12) baseCount = 2;
          else if (random < 0.15) baseCount = 3;
        } else if (baseCount === 2) {
          if (random < 0.18) baseCount = 3;
          else if (random < 0.25) baseCount = 4;
          else if (random < 0.35) baseCount = 1;
        } else if (baseCount >= 3) {
          if (random < 0.22) baseCount = Math.min(7, baseCount + 1);
          else if (random < 0.45) baseCount = Math.max(1, baseCount - 1);
        }
        
        const fluctuatedCount = Math.max(1, Math.min(7, baseCount));
        
        // Create traffic entry
        newTrafficEntries.push({
          timestamp: simDate.toISOString(),
          hour: hours,
          day: day,
          date: simDate.toLocaleDateString(),
          availableCount: fluctuatedCount,
          totalMachines: MACHINES.length,
          occupiedCount: MACHINES.length - fluctuatedCount,
          occupancyRate: ((MACHINES.length - fluctuatedCount) / MACHINES.length * 100).toFixed(1)
        });
        
        // Simulate machine availability for this period
        const activeMachines = MACHINES.filter(m => !isMachineRetired(m.id));
        const availableForPeriod = [];
        
        for (let i = 0; i < Math.min(fluctuatedCount, activeMachines.length); i++) {
          const randomMachine = activeMachines[Math.floor(Math.random() * activeMachines.length)];
          if (!availableForPeriod.includes(randomMachine.id)) {
            availableForPeriod.push(randomMachine.id);
          }
        }
        
        // Update availability counts
        const dateKey = `${simDate.getFullYear()}-${simDate.getMonth()}-${simDate.getDate()}`;
        if (!newAvailabilityCounts[dateKey]) {
          newAvailabilityCounts[dateKey] = {};
        }
        availableForPeriod.forEach(machineId => {
          newAvailabilityCounts[dateKey][machineId] = (newAvailabilityCounts[dateKey][machineId] || 0) + 1;
        });
      }
      
      // Move forward by random interval (15-45 minutes)
      const interval = (15 + Math.random() * 30) * 60 * 1000;
      currentSimTime += interval;
    }
    
    // Merge simulated data with existing data
    if (newTrafficEntries.length > 0) {
      const updatedTrafficHistory = [...trafficHistory, ...newTrafficEntries]
        .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
      
      const trimmedHistory = updatedTrafficHistory.length > 500 
        ? updatedTrafficHistory.slice(-500) 
        : updatedTrafficHistory;
      
      setTrafficHistory(trimmedHistory);
      setMachineAvailabilityCount(newAvailabilityCounts);
      
      // Save to storage
      try {
        await window.storage.set('parlour-traffic-history', JSON.stringify(trimmedHistory));
        await window.storage.set('parlour-machine-availability', JSON.stringify(newAvailabilityCounts));
        console.log(`‚úì Simulated ${newTrafficEntries.length} traffic entries for missed time`);
      } catch (error) {
        console.error('Error saving simulated data:', error);
      }
    }
  };

  const scheduleNextAutoRoll = () => {
    // Random interval between 15-45 minutes (in milliseconds)
    const minInterval = 15 * 60 * 1000; // 15 minutes
    const maxInterval = 45 * 60 * 1000; // 45 minutes
    const randomInterval = Math.floor(Math.random() * (maxInterval - minInterval + 1)) + minInterval;
    
    const nextRoll = Date.now() + randomInterval;
    setNextAutoRollTime(nextRoll);
    
    // Save to storage
    window.storage.set('parlour-next-auto-roll', nextRoll.toString()).catch(err => {
      console.error('Error saving next auto roll time:', err);
    });
  };

  const manualRollMachines = async () => {
    const today = new Date(currentTime);
    const todayDateString = `${today.getFullYear()}-${today.getMonth()}-${today.getDate()}`;
    
    if (lastManualRollDate === todayDateString) {
      alert('Manual roll already used today. Come back tomorrow!');
      return;
    }
    
    await autoRollMachines();
    
    setLastManualRollDate(todayDateString);
    
    try {
      await window.storage.set('parlour-last-manual-roll', todayDateString);
    } catch (error) {
      console.error('Error saving manual roll date:', error);
    }
    
    setAvailableMachines(prev => [...prev]); // Force UI refresh
  };

  const canManualRoll = () => {
    if (!isHallOpen()) return false;
    
    const today = new Date(currentTime);
    const todayDateString = `${today.getFullYear()}-${today.getMonth()}-${today.getDate()}`;
    
    return lastManualRollDate !== todayDateString;
  };

  const retireMachine = useCallback((machineId, weeks) => {
    const weeksNum = parseInt(weeks);
    
    // Validate weeks input
    if (weeksNum < 1 || weeksNum > 4) {
      alert('Retirement period must be between 1 and 4 weeks');
      return;
    }
    
    // Calculate return date
    const returnDate = new Date(currentTime);
    returnDate.setDate(returnDate.getDate() + (weeksNum * 7));
    returnDate.setHours(0, 0, 0, 0);
    
    // Set retirement data
    setRetiredMachines(prev => ({
      ...prev,
      [machineId]: {
        cycle: currentCycle,
        week: currentWeek,
        weeks: weeksNum,
        returnDate: returnDate.toISOString()
      }
    }));
    
    // Remove from available machines
    setAvailableMachines(prev => prev.filter(id => id !== machineId));
    
    // Add calendar note
    const dateKey = `${returnDate.getFullYear()}-${returnDate.getMonth()}-${returnDate.getDate()}`;
    const machine = MACHINES.find(m => m.id === machineId);
    
    const returnNote = `üîß ${machine?.name} returns from retirement today`;
    
    setCalendarNotes(prev => {
      const existingNote = prev[dateKey] || '';
      return {
        ...prev,
        [dateKey]: existingNote ? `${existingNote}\n\n${returnNote}` : returnNote
      };
    });
    
    // Show confirmation
    const weeksText = weeksNum === 1 ? '1 week' : `${weeksNum} weeks`;
    
    alert(`${machine?.name} has been retired for ${weeksText}.\n\nReturn date: ${returnDate.toLocaleString()}\n\nA reminder has been added to the calendar.`);
  }, [currentTime, currentCycle, currentWeek]);



  const getRetirementInfo = useCallback((machineId) => {
    const retirement = retiredMachines[machineId];
    if (!retirement || !isMachineRetired(machineId)) return null;
    
    const returnDate = retirement.returnDate ? new Date(retirement.returnDate) : null;
    const now = new Date(currentTime);
    
    let daysRemaining = 0;
    
    if (returnDate) {
      const today = new Date(now);
      today.setHours(0, 0, 0, 0);
      const returnDateNorm = new Date(returnDate);
      returnDateNorm.setHours(0, 0, 0, 0);
      daysRemaining = Math.ceil((returnDateNorm - today) / (1000 * 60 * 60 * 24));
    }
    
    return {
      startCycle: retirement.cycle,
      startWeek: retirement.week,
      totalWeeks: retirement.weeks,
      returnDate: returnDate,
      daysRemaining: Math.max(0, daysRemaining)
    };
  }, [retiredMachines, isMachineRetired, currentTime]);

  const getPeriodKey = useCallback(() => `C${currentCycle}-W${currentWeek}`, [currentCycle, currentWeek]);
  const getStatKey = useCallback((machineId) => `${getPeriodKey()}-${machineId}`, [getPeriodKey]);

  const getStat = useCallback((machineId, field) => stats[getStatKey(machineId)]?.[field] || 0, [stats, getStatKey]);

  const updateStat = useCallback((machineId, field, value) => {
    const key = getStatKey(machineId);
    setStats(prev => ({
      ...prev,
      [key]: { ...prev[key], [field]: parseInt(value) || 0 }
    }));
  }, [getStatKey]);

  // Calculate percentile rank for a value in an array (0.0 - 1.0)
  const calculatePercentile = (value, allValues) => {
    if (allValues.length === 0) return 0;
    const sorted = [...allValues].sort((a, b) => a - b);
    const index = sorted.findIndex(v => v >= value);
    if (index === -1) return 1.0;
    return index / (sorted.length - 1);
  };

  const calculatePopularityFromDaily = (customCalendarStats = null) => {
    // Use provided stats or fall back to state
    const statsToUse = customCalendarStats || calendarStats;
    
    const today = new Date(currentTime);
    const todayDateKey = `${today.getFullYear()}-${today.getMonth()}-${today.getDate()}`;
    
    // Get yesterday's date for momentum calculation
    const yesterday = new Date(today);
    yesterday.setDate(yesterday.getDate() - 1);
    const yesterdayDateKey = `${yesterday.getFullYear()}-${yesterday.getMonth()}-${yesterday.getDate()}`;
    
    // Get today's calendar stats
    const todayStats = statsToUse[todayDateKey];
    const yesterdayStats = statsToUse[yesterdayDateKey];
    
    // If no data for today, return EXISTING popularity values (don't reset)
    if (!todayStats || !todayStats.machines) {
      // FIXED: Return existing popularity, only initialize NEW machines that don't have values yet
      const existingPop = { ...machinePopularity };
      registry.getActive().forEach(m => {
        if (existingPop[m.id] === undefined) {
          existingPop[m.id] = 0.5; // Only initialize new machines
        }
      });
      return existingPop;
    }
    
    console.log('üìä Calculating popularity from daily stats:', todayStats);
    console.log(`üé∞ Processing ${registry.getActive().length} active machines:`, registry.getActive().map(m => m.name));
    
    // Determine MIN_GAMES threshold based on day of week
    const dayOfWeek = today.getDay();
    const isWeekend = dayOfWeek === 0 || dayOfWeek === 6;
    const MIN_GAMES = isWeekend ? 800 : 500; // Lower threshold on weekdays
    
    // FIXED: Use registry.getActive() to include ALL active machines (system + user)
    const machineData = [];
    const allMedalsOut = [];
    const allBBRounds = [];
    const allRBRounds = [];
    const allLogPlays = [];
    
    registry.getActive().forEach(machine => {
      const machineStats = todayStats.machines?.[machine.id];
      
      // Explicit zero handling for unplayed machines
      const gamesPlayed = machineStats?.totalPlays || 0;
      const medalsOut = machineStats?.medalsOut || 0;
      const bbRounds = machineStats?.bbCount || 0;
      const rbRounds = machineStats?.rbCount || 0;
      const logPlays = Math.log(gamesPlayed + 1); // +1 to avoid log(0)
      
      machineData.push({
        id: machine.id,
        gamesPlayed,
        medalsOut,
        bbRounds,
        rbRounds,
        logPlays
      });
      
      allMedalsOut.push(medalsOut);
      allBBRounds.push(bbRounds);
      allRBRounds.push(rbRounds);
      allLogPlays.push(logPlays);
    });
    
    // Calculate base scores for each machine
    const baseScores = {};
    
    machineData.forEach(data => {
      // STEP 1: Activity Gate
      const activityPenalty = data.gamesPlayed < MIN_GAMES ? 0.6 : 1.0;
      
      // STEP 2: Daily Normalization (Percentiles)
      const medalScore = calculatePercentile(data.medalsOut, allMedalsOut);
      const bbScore = calculatePercentile(data.bbRounds, allBBRounds);
      const rbScore = calculatePercentile(data.rbRounds, allRBRounds);
      const playScore = calculatePercentile(data.logPlays, allLogPlays);
      
      // STEP 3: Base Popularity Score (weighted)
      const baseScore = 
        0.32 * medalScore +
        0.33 * bbScore +
        0.20 * rbScore +
        0.15 * playScore;
      
      baseScores[data.id] = {
        baseScore,
        activityPenalty
      };
    });
    
    // STEP 4 & 5: Momentum Adjustment and Final Score
    const finalPopularity = {};
    
    registry.getActive().forEach(machine => {
      const machineStats = todayStats.machines[machine.id];
      
      // Check if this is a newly added machine (no yesterday stats but has today stats)
      const isNewMachine = machineStats && 
                          (!yesterdayStats || !yesterdayStats.machines || !yesterdayStats.machines[machine.id]);
      
      if (!baseScores[machine.id]) {
        // No data today - exclude from ranking (set to 0)
        finalPopularity[machine.id] = 0;
        return;
      }
      
      const { baseScore, activityPenalty } = baseScores[machine.id];
      
      let momentum = 1.0;
      
      if (isNewMachine) {
        // New machine boost: "new and exciting"
        momentum = 1.1;
        console.log(`üÜï ${machine.name} is new - applying excitement boost (1.1x)`);
      } else if (yesterdayStats && yesterdayStats.machines && yesterdayStats.machines[machine.id]) {
        // Calculate yesterday's base score for momentum
        const yesterdayData = yesterdayStats.machines[machine.id];
        const yGamesPlayed = yesterdayData.totalPlays || 0;
        
        if (yGamesPlayed > 0) {
          // Need to recalculate yesterday's percentiles using yesterday's full dataset
          const yesterdayMachineData = [];
          const yAllMedalsOut = [];
          const yAllBBRounds = [];
          const yAllRBRounds = [];
          const yAllLogPlays = [];
          
          Object.entries(yesterdayStats.machines).forEach(([mId, mStats]) => {
            const yPlays = mStats.totalPlays || 0;
            if (yPlays === 0) return;
            
            const yMedals = mStats.medalsOut || 0;
            const yBB = mStats.bbCount || 0;
            const yRB = mStats.rbCount || 0;
            const yLog = Math.log(yPlays + 1);
            
            yesterdayMachineData.push({ id: mId, medalsOut: yMedals, bbRounds: yBB, rbRounds: yRB, logPlays: yLog });
            yAllMedalsOut.push(yMedals);
            yAllBBRounds.push(yBB);
            yAllRBRounds.push(yRB);
            yAllLogPlays.push(yLog);
          });
          
          const yData = yesterdayMachineData.find(d => d.id === machine.id);
          
          if (yData) {
            const yMedalScore = calculatePercentile(yData.medalsOut, yAllMedalsOut);
            const yBBScore = calculatePercentile(yData.bbRounds, yAllBBRounds);
            const yRBScore = calculatePercentile(yData.rbRounds, yAllRBRounds);
            const yPlayScore = calculatePercentile(yData.logPlays, yAllLogPlays);
            
            const yesterdayBaseScore = 
              0.32 * yMedalScore +
              0.33 * yBBScore +
              0.20 * yRBScore +
              0.15 * yPlayScore;
            
            // Calculate momentum with clamping
            const momentumDelta = baseScore - yesterdayBaseScore;
            momentum = Math.max(0.85, Math.min(1.15, 1.0 + 0.1 * momentumDelta));
          }
        }
      }
      
      // STEP 5: Final Score
      const finalScore = baseScore * momentum * activityPenalty;
      
      finalPopularity[machine.id] = finalScore;
    });
    
    return finalPopularity;
  };

  const recalculatePopularity = useCallback(async () => {
    if (!window.confirm('Recalculate all machine popularity from today\'s daily stats?\n\nThis will override current popularity values.')) {
      return;
    }
    
    try {
      setIsLoading(true);
      const newPopularity = calculatePopularityFromDaily();
      setMachinePopularity(newPopularity);
      await window.storage.set('parlour-popularity', JSON.stringify(newPopularity));
      setIsLoading(false);
      alert('SUCCESS! Popularity recalculated.');
    } catch (error) {
      setIsLoading(false);
      alert('ERROR: ' + error.message);
    }
  }, [calculatePopularityFromDaily]);

  // OPTIMIZED: Data pruning to prevent unbounded growth
  const pruneOldData = useCallback(async () => {
    const now = new Date(currentTime);
    const pruneDate = new Date(now);
    pruneDate.setDate(pruneDate.getDate() - 90); // Keep 90 days of data
    
    let pruned = false;
    
    // Prune old calendar stats (keep last 90 days)
    const newCalendarStats = { ...calendarStats };
    Object.keys(newCalendarStats).forEach(dateKey => {
      try {
        const [year, month, day] = dateKey.split('-').map(Number);
        const entryDate = new Date(year, month, day);
        if (entryDate < pruneDate) {
          delete newCalendarStats[dateKey];
          pruned = true;
        }
      } catch (err) {
        console.error('Error pruning calendar stat:', err);
      }
    });
    
    if (pruned) {
      setCalendarStats(newCalendarStats);
    }
    
    // Prune old daily traffic graphs (keep last 90 days)
    const newDailyGraphs = { ...dailyTrafficGraphs };
    let graphsPruned = false;
    Object.keys(newDailyGraphs).forEach(dateKey => {
      try {
        const [year, month, day] = dateKey.split('-').map(Number);
        const entryDate = new Date(year, month, day);
        if (entryDate < pruneDate) {
          delete newDailyGraphs[dateKey];
          graphsPruned = true;
        }
      } catch (err) {
        console.error('Error pruning daily graph:', err);
      }
    });
    
    if (graphsPruned) {
      setDailyTrafficGraphs(newDailyGraphs);
    }
    
    // Prune old pre-determined days (keep last 30 days)
    const planPruneDate = new Date(now);
    planPruneDate.setDate(planPruneDate.getDate() - 30);
    
    const newPreDeterminedDays = { ...preDeterminedDays };
    let plansPruned = false;
    Object.keys(newPreDeterminedDays).forEach(dateKey => {
      try {
        const [year, month, day] = dateKey.split('-').map(Number);
        const entryDate = new Date(year, month, day);
        if (entryDate < planPruneDate) {
          delete newPreDeterminedDays[dateKey];
          plansPruned = true;
        }
      } catch (err) {
        console.error('Error pruning day plan:', err);
      }
    });
    
    if (plansPruned) {
      setPreDeterminedDays(newPreDeterminedDays);
    }
    
    // Trim traffic history to last 1000 entries
    if (trafficHistory.length > 1000) {
      const trimmedHistory = trafficHistory.slice(-1000);
      setTrafficHistory(trimmedHistory);
    }
    
    // Save pruned data if anything was removed
    if (pruned || graphsPruned || plansPruned || trafficHistory.length > 1000) {
      try {
        const allData = {
          stats,
          settings,
          adjustments,
          designatedLosers,
          allCycles,
          machinePopularity,
          generalNotes,
          retiredMachines,
          procedures,
          calendarNotes,
          customPromotions,
          calendarStats: newCalendarStats,
          trafficHistory: trafficHistory.length > 1000 ? trafficHistory.slice(-1000) : trafficHistory,
          dailyTrafficGraphs: newDailyGraphs,
          allTimeStats,
          machineAvailabilityCount,
          preDeterminedDays: newPreDeterminedDays,
          dailyStats,
          weeklyStats,
          activeHanabiVariant,
          lastManualRollDate,
          nextAutoRollTime,
          lastHanabiCheckMonday,
          nextHanabiSwapWeeks,
          version: '5.0',
          lastPruned: new Date().toISOString()
        };
        
        await window.storage.set('parlour-data', JSON.stringify(allData));
      } catch (error) {
        console.error('Error saving pruned data:', error);
      }
    }
  }, [calendarStats, dailyTrafficGraphs, preDeterminedDays, trafficHistory, currentTime, stats, settings, adjustments, designatedLosers, allCycles, machinePopularity, generalNotes, retiredMachines, procedures, calendarNotes, customPromotions, allTimeStats, machineAvailabilityCount, dailyStats, weeklyStats, activeHanabiVariant, lastManualRollDate, nextAutoRollTime, lastHanabiCheckMonday, nextHanabiSwapWeeks]);

  // Run pruning daily at midnight
  useEffect(() => {
    const checkPruning = () => {
      const now = new Date(currentTime);
      const hours = now.getHours();
      const minutes = now.getMinutes();
      
      // Run at midnight (00:00-00:10 window to avoid missing it)
      if (hours === 0 && minutes < 10) {
        const lastPruneKey = 'last-prune-date';
        const todayKey = `${now.getFullYear()}-${now.getMonth()}-${now.getDate()}`;
        
        const lastPrune = localStorage.getItem(lastPruneKey);
        
        if (lastPrune !== todayKey) {
          console.log('üóëÔ∏è Running daily data pruning...');
          pruneOldData();
          localStorage.setItem(lastPruneKey, todayKey);
        }
      }
    };
    
    checkPruning();
    const pruneInterval = setInterval(checkPruning, 60000); // Check every minute
    
    return () => clearInterval(pruneInterval);
  }, [currentTime, pruneOldData]);

  // NEW: Properly defined updatePopularity function - no circular dependencies
  const updatePopularity = async (customCalendarStats = null) => {
    try {
      const newPopularity = calculatePopularityFromDaily(customCalendarStats);
      setMachinePopularity(newPopularity);
      setPopularityLastUpdated(new Date().toISOString());
      await window.storage.set('parlour-popularity', JSON.stringify(newPopularity));
    } catch (error) {
      console.error('‚ùå Error updating popularity:', error);
    }
  };
  
  // NEW: Load popularity from most recent calendar entry
  const loadLatestPopularity = useCallback(async () => {
    setPopularityRefreshStatus('üîÑ Loading...');
    try {
      // Load fresh calendar stats from storage
      let calStats = calendarStats;
      
      // If calendar stats not in state, load from storage
      if (!calStats || Object.keys(calStats).length === 0) {
        setPopularityRefreshStatus('üìÇ Loading calendar stats from storage...');
        try {
          const calendarStatsData = await window.storage.get('parlour-calendar-stats');
          if (calendarStatsData) {
            calStats = JSON.parse(calendarStatsData.value);
            setCalendarStats(calStats); // Update state too
            setPopularityRefreshStatus(`üìä Found ${Object.keys(calStats).length} calendar entries`);
          }
        } catch (error) {
          setPopularityRefreshStatus('‚ùå Error loading calendar stats: ' + error.message);
          return;
        }
      } else {
        setPopularityRefreshStatus(`üìä Using ${Object.keys(calStats).length} calendar entries from state`);
      }
      
      if (!calStats || Object.keys(calStats).length === 0) {
        setPopularityRefreshStatus('‚ö†Ô∏è No calendar stats found');
        return;
      }
      
      // Find most recent calendar entry with popularity data
      const sortedEntries = Object.entries(calStats)
        .filter(([_, entry]) => entry.popularity)
        .sort((a, b) => new Date(b[1].date) - new Date(a[1].date));
      
      setPopularityRefreshStatus(`üîç Found ${sortedEntries.length} entries with popularity data`);
      
      if (sortedEntries.length > 0) {
        const [dateKey, latestEntry] = sortedEntries[0];
        setMachinePopularity(latestEntry.popularity);
        setPopularityLastUpdated(latestEntry.popularityUpdated || latestEntry.date);
        
        // Save to storage
        await window.storage.set('parlour-popularity', JSON.stringify(latestEntry.popularity));
        
        const updateDate = new Date(latestEntry.popularityUpdated || latestEntry.date);
        setPopularityRefreshStatus(`‚úÖ Refreshed from ${updateDate.toLocaleString('en-US', { 
          month: 'short', 
          day: 'numeric', 
          hour: '2-digit', 
          minute: '2-digit',
          hour12: true
        })}`);
        
        // Clear status after 5 seconds
        setTimeout(() => setPopularityRefreshStatus(''), 5000);
      } else {
        setPopularityRefreshStatus('‚ö†Ô∏è No calendar entries with popularity data found');
      }
    } catch (error) {
      setPopularityRefreshStatus('‚ùå Error: ' + error.message);
    }
  }, [calendarStats]);

  const calculateAndSaveDifference = async (machineId) => {
    const accumulated = accumulatedInputs[machineId] || {};
    const skipCalculation = accumulatedInputs[machineId]?.skipCalculation || false;
    const today = new Date(currentTime);
    
    const fields = ['totalPlays', 'medalsIn', 'medalsOut', 'bbCount', 'rbCount'];
    
    let todayActivity = {};
    
    if (skipCalculation) {
      // Manual entry mode - use values as-is without any calculation
      fields.forEach(field => {
        const manualValue = parseInt(accumulated[field]) || 0;
        todayActivity[field] = manualValue;
        
        // Update the "Today" stats display with manual values
        updateStat(machineId, field, manualValue);
      });
    } else {
      // Normal mode - calculate difference from yesterday's CALENDAR stats
      
      // Get yesterday's date
      const yesterday = new Date(today);
      yesterday.setDate(yesterday.getDate() - 1);
      const yesterdayDateKey = `${yesterday.getFullYear()}-${yesterday.getMonth()}-${yesterday.getDate()}`;
      
      // Look up yesterday's calendar entry for this machine
      const yesterdayCalendar = calendarStats[yesterdayDateKey];
      const yesterdayMachineStats = yesterdayCalendar?.machines?.[machineId] || {
        totalPlays: 0,
        medalsIn: 0,
        medalsOut: 0,
        bbCount: 0,
        rbCount: 0
      };
      
      // Calculate today's activity (today's counter reading - yesterday's counter reading from CALENDAR)
      fields.forEach(field => {
        const todayReading = parseInt(accumulated[field]) || 0;
        const yesterdayReading = yesterdayMachineStats[field] || 0;
        const activity = Math.max(0, todayReading - yesterdayReading);
        todayActivity[field] = activity;
        
        // Update the "Today" stats display
        updateStat(machineId, field, activity);
      });
    }
    
    // Update All-Time stats (add today's activity to existing all-time totals)
    const newAllTimeStats = { ...allTimeStats };
    fields.forEach(field => {
      const currentAllTime = allTimeStats[`${machineId}-${field}`] || 0;
      const newTotal = currentAllTime + todayActivity[field];
      newAllTimeStats[`${machineId}-${field}`] = newTotal;
    });
    setAllTimeStats(newAllTimeStats);
    
    // Clear the input fields
    setAccumulatedInputs(prev => {
      const updated = { ...prev };
      delete updated[machineId];
      return updated;
    });
    
    // Save all-time stats to storage immediately
    try {
      await window.storage.set('parlour-alltime-stats', JSON.stringify(newAllTimeStats));
      
      // CRITICAL: Save the "Today" stats to storage so they persist
      await window.storage.set('parlour-stats', JSON.stringify(stats));
      
      // Recalculate and save popularity based on new daily stats
      await updatePopularity();
      
      const modeMessage = skipCalculation 
        ? '\n\n‚ö†Ô∏è Manual Entry Mode: Values entered directly without calculation.'
        : '\n\n‚úì Automatic Mode: Today\'s activity calculated from yesterday\'s calendar stats.';
      
      alert('Stats saved successfully!' + modeMessage + '\n\nAll-Time stats updated.\n\nMachine popularity recalculated using Daily Algorithm:\n‚Ä¢ Medals Out (32%)\n‚Ä¢ BB Rounds (33%)\n‚Ä¢ RB Rounds (20%)\n‚Ä¢ Play Volume (15%)\n‚Ä¢ Plus momentum & activity adjustments');
    } catch (error) {
      console.error('Error saving stats:', error);
      alert('Error saving stats: ' + error.message);
    }
  };

  const getAccumulatedInput = useCallback((machineId, field) => {
    return accumulatedInputs[machineId]?.[field] || '';
  }, [accumulatedInputs]);

  const setAccumulatedInput = useCallback((machineId, field, value) => {
    setAccumulatedInputs(prev => ({
      ...prev,
      [machineId]: { ...prev[machineId], [field]: value }
    }));
  }, []);

  const getSetting = useCallback((machineId) => settings[`${getPeriodKey()}-${machineId}`] || 2, [settings, getPeriodKey]);

  const updateSetting = useCallback((machineId, value) => {
    setSettings(prev => ({ ...prev, [`${getPeriodKey()}-${machineId}`]: parseInt(value) }));
  }, [getPeriodKey]);

  const getAdjustment = useCallback((machineId, field) => adjustments[getStatKey(machineId)]?.[field] || '', [adjustments, getStatKey]);

  const updateAdjustment = useCallback((machineId, field, value) => {
    const key = getStatKey(machineId);
    setAdjustments(prev => ({
      ...prev,
      [key]: { ...prev[key], [field]: value }
    }));
  }, [getStatKey]);

  const formatNumber = useCallback((num) => (num || 0).toLocaleString('en-US'), []);

  const calculateTotals = useCallback((machineId) => {
    const total = getStat(machineId, 'totalPlays');
    const medalsIn = getStat(machineId, 'medalsIn');
    const medalsOut = getStat(machineId, 'medalsOut');
    const payout = medalsIn > 0 ? ((medalsOut / medalsIn) * 100).toFixed(1) : 0;
    return { total, medalsIn, medalsOut, payout };
  }, [getStat]);

  const calculateAllTotals = useCallback(() => {
    const totals = { totalPlays: 0, medalsIn: 0, medalsOut: 0, bbCount: 0, rbCount: 0 };
    
    MACHINES.forEach(machine => {
      // Only include machines that have been played (totalPlays > 0)
      const machineTotal = getStat(machine.id, 'totalPlays');
      if (machineTotal > 0) {
        Object.keys(totals).forEach(field => {
          totals[field] += getStat(machine.id, field);
        });
      }
    });
    
    const payout = totals.medalsIn > 0 ? ((totals.medalsOut / totals.medalsIn) * 100).toFixed(1) : 0;
    return { ...totals, payout };
  }, [getStat, MACHINES]);

  const sortedMachinesByPopularity = useMemo(() => {
    return [...MACHINES].sort((a, b) => {
      const popA = machinePopularity[a.id] || 0.50;
      const popB = machinePopularity[b.id] || 0.50;
      
      // Normalize to 0-1 range if stored as percentage (old format)
      const normalizedA = popA > 1 ? popA / 100 : popA;
      const normalizedB = popB > 1 ? popB / 100 : popB;
      
      return normalizedB - normalizedA;
    });
  }, [machinePopularity, MACHINES]);

  const activeMachinesCount = useMemo(() => {
    return MACHINES.filter(m => {
      const retirement = retiredMachines[m.id];
      if (!retirement) return true;
      
      const now = new Date(currentTime);
      const returnDate = new Date(retirement.returnDate);
      
      const today = new Date(now);
      today.setHours(0, 0, 0, 0);
      
      const returnDay = new Date(returnDate);
      returnDay.setHours(0, 0, 0, 0);
      
      return today >= returnDay;
    }).length;
  }, [retiredMachines, currentTime, MACHINES]);

  const retiredMachinesList = useMemo(() => {
    return Object.entries(retiredMachines || {}).filter(([id]) => {
      try {
        return isMachineRetired(id);
      } catch (err) {
        console.error('Error checking retirement status:', err);
        return false;
      }
    });
  }, [retiredMachines, isMachineRetired]);

  const historicalData = useMemo(() => {
    const timeline = [];
    allCycles.forEach(cycle => {
      [1, 2, 3, 4].forEach(week => {
        const periodKey = `C${cycle}-W${week}`;
        let periodData = {
          period: `C${cycle} W${week}`,
          cycle, week,
          totalPlays: 0, medalsIn: 0, medalsOut: 0, bbCount: 0, rbCount: 0
        };
        MACHINES.forEach(machine => {
          const key = `${periodKey}-${machine.id}`;
          if (stats[key]) {
            periodData.totalPlays += stats[key].totalPlays || 0;
            periodData.medalsIn += stats[key].medalsIn || 0;
            periodData.medalsOut += stats[key].medalsOut || 0;
            periodData.bbCount += stats[key].bbCount || 0;
            periodData.rbCount += stats[key].rbCount || 0;
          }
        });
        periodData.payout = periodData.medalsIn > 0 ? ((periodData.medalsOut / periodData.medalsIn) * 100).toFixed(1) : 0;
        if (periodData.totalPlays > 0) timeline.push(periodData);
      });
    });
    return timeline;
  }, [allCycles, stats, MACHINES]);

  const currentPeriodTotals = useMemo(() => {
    const totals = { totalPlays: 0, medalsIn: 0, medalsOut: 0, bbCount: 0, rbCount: 0 };
    
    MACHINES.forEach(machine => {
      Object.keys(totals).forEach(field => {
        totals[field] += getStat(machine.id, field);
      });
    });
    
    const payout = totals.medalsIn > 0 ? ((totals.medalsOut / totals.medalsIn) * 100).toFixed(1) : 0;
    return { ...totals, payout };
  }, [stats, MACHINES, currentCycle, currentWeek]);

  const allTimeTotals = useMemo(() => {
    const totals = {
      totalPlays: 0,
      medalsIn: 0,
      medalsOut: 0,
      bbCount: 0,
      rbCount: 0
    };
    
    MACHINES.forEach(machine => {
      totals.totalPlays += allTimeStats[`${machine.id}-totalPlays`] || 0;
      totals.medalsIn += allTimeStats[`${machine.id}-medalsIn`] || 0;
      totals.medalsOut += allTimeStats[`${machine.id}-medalsOut`] || 0;
      totals.bbCount += allTimeStats[`${machine.id}-bbCount`] || 0;
      totals.rbCount += allTimeStats[`${machine.id}-rbCount`] || 0;
    });
    
    const allTimePayout = totals.medalsIn > 0 
      ? ((totals.medalsOut / totals.medalsIn) * 100).toFixed(1)
      : 0;
    
    return { ...totals, payout: allTimePayout };
  }, [allTimeStats, MACHINES]);

  const isHallOpen = useCallback(() => {
    return true; // 24/7 operation
  }, []);

  const getClosingWarning = useCallback(() => {
    return null; // No closing warnings - 24/7 operation
  }, []);

  const isTwoHoursBeforeClosing = useCallback(() => {
    // Show reminder at midnight if stats not captured for previous day
    const now = new Date(currentTime);
    const hours = now.getHours();
    
    if (hours === 0 || hours === 1) { // Midnight to 1 AM
      const yesterday = new Date(now);
      yesterday.setDate(now.getDate() - 1);
      const yesterdayKey = `${yesterday.getFullYear()}-${yesterday.getMonth()}-${yesterday.getDate()}`;
      return !calendarStats[yesterdayKey];
    }
    return false;
  }, [currentTime, calendarStats]);

  const getBaseAvailableCount = useCallback(() => {
    const day = currentTime.getDay();
    const hours = currentTime.getHours();
    const isWeekend = day === 0 || day === 6;
    const isHoliday = getCurrentHoliday() !== undefined;
    const isGoldenWeek = getCurrentHoliday()?.name.includes('Golden Week');
    const isSilverWeek = getCurrentHoliday()?.name.includes('Silver Week');

    let baseCount;

    // Overnight period (graveyard shift)
    if (hours >= 2 && hours < 6) {
      baseCount = isWeekend ? 7 : 6; // Lowest attendance
    }
    // Late night stragglers
    else if (hours >= 0 && hours < 2) {
      baseCount = 5;
    }
    // Early morning transition
    else if (hours >= 6 && hours < 8) {
      baseCount = 5;
    }
    // Morning (existing logic)
    else if (hours >= 8 && hours < 11) {
      baseCount = isWeekend ? 6 : 5;
    }
    // Lunch rush
    else if (hours >= 11 && hours < 13) {
      baseCount = 3;
    }
    // Afternoon/evening rush
    else if (isWeekend && hours >= 13 && hours < 22) {
      baseCount = 2;
    }
    else if (!isWeekend && hours >= 18 && hours < 22) {
      baseCount = 2;
    }
    // Late evening
    else if (hours >= 22) {
      baseCount = 4;
    }
    // Default afternoon
    else {
      baseCount = 4;
    }

    if (isGoldenWeek || isSilverWeek) {
      baseCount = Math.max(1, baseCount - 2);
    } else if (isHoliday) {
      baseCount = Math.max(1, baseCount - 1);
    }

    return baseCount;
  }, [currentTime, getCurrentHoliday]);

  const getAvailableMachineCount = useCallback(() => currentAvailableCount !== null ? currentAvailableCount : getBaseAvailableCount(), [currentAvailableCount, getBaseAvailableCount]);

  const calculateFluctuatedCount = useCallback(() => {
    let baseCount = getBaseAvailableCount();
    const random = Math.random();
    
    // Add time-based micro-variations (represents natural ebb and flow)
    const minute = currentTime.getMinutes();
    const microVariation = Math.sin(minute * 0.1) * 0.3; // Subtle sine wave variation
    
    if (baseCount === 1) {
      if (random < 0.12) baseCount = 2;
      else if (random < 0.15) baseCount = 3;
    }
    else if (baseCount === 2) {
      if (random < 0.18) baseCount = 3;
      else if (random < 0.25) baseCount = 4;
      else if (random < 0.35) baseCount = 1;
    }
    else if (baseCount === 3) {
      if (random < 0.22 + microVariation) baseCount = 4;
      else if (random < 0.32 + microVariation) baseCount = 5;
      else if (random < 0.45) baseCount = 2;
      else if (random < 0.48) baseCount = 1;
    }
    else if (baseCount === 4) {
      if (random < 0.28 + microVariation) baseCount = 5;
      else if (random < 0.38 + microVariation) baseCount = 6;
      else if (random < 0.55) baseCount = 3;
      else if (random < 0.62) baseCount = 2;
    }
    else if (baseCount >= 5) {
      if (random < 0.18) baseCount = Math.max(4, baseCount - 1);
      else if (random < 0.28) baseCount = Math.max(3, baseCount - 2);
      else if (random < 0.35) baseCount = Math.min(7, baseCount + 1);
      else if (random < 0.38) baseCount = Math.max(2, baseCount - 3);
    }

    return Math.max(1, Math.min(7, baseCount));
  }, [getBaseAvailableCount, currentTime]);

  const getHallStatus = useCallback(() => {
    const currentHoliday = getCurrentHoliday();
    const availableCount = getAvailableMachineCount();
    
    let statusText = 'OPEN 24/7';
    let statusColor = 'text-green-400';
    let trafficText = '';
    let trafficColor = 'text-slate-400';
    
    // Check for special holiday periods first
    if (currentHoliday?.name.includes('Golden Week') || currentHoliday?.name.includes('Silver Week')) {
      trafficText = `${currentHoliday.name.toUpperCase()} RUSH`;
      trafficColor = 'text-red-400';
    } else if (currentHoliday) {
      trafficText = `HOLIDAY TRAFFIC (${currentHoliday.name})`;
      trafficColor = 'text-orange-400';
    } else if (availableCount >= 5) {
      trafficText = 'LOW TRAFFIC';
      trafficColor = 'text-green-400';
    } else if (availableCount >= 3) {
      trafficText = 'MODERATE TRAFFIC';
      trafficColor = 'text-yellow-400';
    } else {
      trafficText = 'PEAK TRAFFIC';
      trafficColor = 'text-orange-400';
    }
    
    return { statusText, statusColor, trafficText, trafficColor };
  }, [getCurrentHoliday, getAvailableMachineCount]);

  const formatCurrentDateTime = useCallback(() => {
    const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
    const months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
    const dayName = days[displayTime.getDay()];
    const monthName = months[displayTime.getMonth()];
    const date = displayTime.getDate();
    const year = displayTime.getFullYear();
    const hours = displayTime.getHours().toString().padStart(2, '0');
    const minutes = displayTime.getMinutes().toString().padStart(2, '0');
    const seconds = displayTime.getSeconds().toString().padStart(2, '0');
    return {
      date: `${dayName}, ${monthName} ${date}, ${year}`,
      time: `${hours}:${minutes}:${seconds}`
    };
  }, [displayTime]);

  const getNextRollTime = () => {
    const nextHour = new Date(currentTime);
    nextHour.setHours(currentTime.getHours() + 1, 0, 0, 0);
    const remaining = nextHour.getTime() - currentTime.getTime();
    
    if (remaining <= 0) return null;
    
    const mins = Math.floor(remaining / 60000);
    const secs = Math.floor((remaining % 60000) / 1000);
    return `${mins}m ${secs}s`;
  };

  const getHistoricalData = useCallback(() => historicalData, [historicalData]);

  const getMachineHistoricalData = useCallback((machineId) => {
    const timeline = [];
    allCycles.forEach(cycle => {
      [1, 2, 3, 4].forEach(week => {
        const periodKey = `C${cycle}-W${week}`;
        const key = `${periodKey}-${machineId}`;
        
        if (stats[key] && stats[key].totalPlays > 0) {
          const data = stats[key];
          timeline.push({
            period: `C${cycle} W${week}`,
            totalPlays: data.totalPlays || 0,
            medalsIn: data.medalsIn || 0,
            medalsOut: data.medalsOut || 0,
            bbCount: data.bbCount || 0,
            rbCount: data.rbCount || 0,
            payout: data.medalsIn > 0 ? ((data.medalsOut / data.medalsIn) * 100).toFixed(1) : 0
          });
        }
      });
    });
    return timeline;
  }, [allCycles, stats]);

  const resetForm = () => {
    setMachineForm({
      id: '',
      name: '',
      allowedOdds: [2, 5, 6],
      neverAllowed: [1],
      initial: 2
    });
    setMachineFormMode('add');
    setEditingMachineId(null);
  };

  const handleAddMachine = async () => {
    try {
      // Validate ID format
      if (!/^[a-z0-9_]+$/i.test(machineForm.id)) {
        alert('Machine ID must contain only letters, numbers, and underscores');
        return;
      }

      // Validate name
      if (machineForm.name.trim().length < 2) {
        alert('Machine name must be at least 2 characters');
        return;
      }

      // Validate odds
      if (machineForm.allowedOdds.length === 0) {
        alert('Must select at least one allowed odds setting');
        return;
      }

      const newMachine = registry.addUserMachine(machineForm);
      
      // Initialize popularity for new machine
      setMachinePopularity(prev => ({
        ...prev,
        [newMachine.id]: 0.5
      }));

      // Update registry state to trigger re-render
      setRegistryVersion(prev => prev + 1);
      
      // Regenerate today's day plan to include the new machine
      const now = new Date(currentTime);
      const todayKey = `${now.getFullYear()}-${now.getMonth()}-${now.getDate()}`;
      
      const newDayPlan = generateDayPlan(now);
      
      const updatedPlans = {
        ...preDeterminedDays,
        [todayKey]: newDayPlan
      };
      setPreDeterminedDays(updatedPlans);
      setCurrentDayPlan(newDayPlan);
      
      // Update available machines to current hour from new plan
      const currentHour = now.getHours();
      const currentHourPlan = newDayPlan.hourlySchedule.find(h => h.hour === currentHour);
      
      if (currentHourPlan) {
        setAvailableMachines(currentHourPlan.availableMachines);
        setCurrentAvailableCount(currentHourPlan.availableCount);
      }
      
      // Save updated day plan
      try {
        await window.storage.set('parlour-predetermined-days', JSON.stringify(updatedPlans));
      } catch (error) {
        console.error('Error saving updated day plan:', error);
      }
      
      // Save to storage immediately
      try {
        await window.storage.set('parlour-data', JSON.stringify({
          stats,
          settings,
          adjustments,
          designatedLosers,
          allCycles,
          machinePopularity: { ...machinePopularity, [newMachine.id]: 0.5 },
          generalNotes,
          retiredMachines,
          procedures,
          machinesIAmPlaying,
          calendarNotes,
          customPromotions,
          calendarStats,
          trafficHistory,
          dailyTrafficGraphs,
          allTimeStats,
          machineAvailabilityCount,
          preDeterminedDays,
          dailyStats,
          weeklyStats,
          activeHanabiVariant,
          lastManualRollDate,
          nextAutoRollTime,
          lastHanabiCheckMonday,
          nextHanabiSwapWeeks,
          userMachines: registry.serialize(),
          version: '5.1',
          lastSaved: new Date().toISOString()
        }));
      } catch (error) {
        console.error('Error saving machine:', error);
        alert('Error saving machine: ' + error.message);
        return;
      }
      
      alert(`‚úÖ Machine "${newMachine.name}" added successfully!`);
      resetForm();
    } catch (error) {
      alert('‚ùå Error adding machine: ' + error.message);
    }
  };

  const handleUpdateMachine = async () => {
    try {
      const updated = registry.updateUserMachine(editingMachineId, machineForm);
      
      // Update registry trigger
      setRegistryVersion(prev => prev + 1);
      
      await saveData();
      
      alert(`‚úÖ Machine "${updated.name}" updated successfully!`);
      resetForm();
    } catch (error) {
      alert('‚ùå Error updating machine: ' + error.message);
    }
  };

  const handleDeactivate = async (machineId) => {
    const machine = registry.getById(machineId);
    if (!confirm(`Deactivate "${machine.name}"?\n\nThis will hide the machine from the floor but preserve all historical data.`)) {
      return;
    }

    try {
      registry.deactivateUserMachine(machineId);
      
      // Update registry trigger
      setRegistryVersion(prev => prev + 1);
      
      await saveData();
      
      alert(`‚úÖ Machine "${machine.name}" deactivated`);
    } catch (error) {
      alert('‚ùå Error deactivating machine: ' + error.message);
    }
  };

  const handleReactivate = async (machineId) => {
    try {
      const reactivated = registry.reactivateUserMachine(machineId);
      
      // Update registry trigger
      setRegistryVersion(prev => prev + 1);
      
      await saveData();
      
      alert(`‚úÖ Machine "${reactivated.name}" reactivated`);
    } catch (error) {
      alert('‚ùå Error reactivating machine: ' + error.message);
    }
  };

  const startEdit = (machine) => {
    setMachineForm({
      id: machine.id,
      name: machine.name,
      allowedOdds: machine.allowedOdds,
      neverAllowed: machine.neverAllowed,
      initial: machine.initial
    });
    setEditingMachineId(machine.id);
    setMachineFormMode('edit');
  };

  const toggleOddsSetting = (setting) => {
    setMachineForm(prev => {
      const isInAllowed = prev.allowedOdds.includes(setting);
      const isInNever = prev.neverAllowed.includes(setting);

      if (isInAllowed) {
        // Move to never allowed
        return {
          ...prev,
          allowedOdds: prev.allowedOdds.filter(o => o !== setting),
          neverAllowed: [...prev.neverAllowed, setting]
        };
      } else if (isInNever) {
        // Remove from never allowed (neutral)
        return {
          ...prev,
          neverAllowed: prev.neverAllowed.filter(o => o !== setting)
        };
      } else {
        // Add to allowed
        return {
          ...prev,
          allowedOdds: [...prev.allowedOdds, setting]
        };
      }
    });
  };

  const RetirementTab = () => {
    return (
      <div className="space-y-4">
        {MACHINES.map(machine => {
          const isRetired = isMachineRetired(machine.id);
          const retirementInfo = getRetirementInfo(machine.id);
          const selectedWeeks = retireWeeksState[machine.id] ?? 1;
          
          return (
            <div key={machine.id} className={`${isNightMode ? 'bg-slate-900/70' : 'bg-slate-800/50'} backdrop-blur rounded-lg p-6 border transition-colors duration-1000 ${
              isRetired ? 'border-yellow-500/40' : 'border-purple-500/20'
            }`}>
              <div className="flex justify-between items-start">
                <div>
                  <h4 className="text-lg font-bold text-purple-300 mb-1">{machine.name}</h4>
                  {isRetired ? (
                    <div className="space-y-1">
                      <div className="text-yellow-400 font-medium">üîß Currently Retired</div>
                                                {retirementInfo?.returnDate && (
                        <>
                          <div className="text-sm text-emerald-300">
                            Returns: {retirementInfo.returnDate.toLocaleString()}
                          </div>
                          {retirementInfo.daysRemaining > 0 && (
                            <div className="text-sm text-yellow-300">
                              {retirementInfo.daysRemaining} day{retirementInfo.daysRemaining !== 1 ? 's' : ''} remaining
                            </div>
                          )}
                          <div className="text-xs text-slate-400 mt-2">
                            ‚ö†Ô∏è Machine will automatically restore on return date
                          </div>
                        </>
                      )}
                    </div>
                  ) : (
                    <div className="text-green-400 text-sm">‚úì Active</div>
                  )}
                </div>
                <div className="flex flex-col gap-3">
                  {!isRetired ? (
                    <>
                      <div className="bg-slate-700/50 border border-slate-600 rounded-lg p-4">
                        <div className="text-sm font-bold text-slate-300 mb-3">Retirement Period: <span className="text-yellow-300">{selectedWeeks === 1 ? '1 week' : `${selectedWeeks} weeks`}</span></div>
                        <div className="flex flex-wrap gap-2">
                          {[
                            { value: 1, label: '1 wk' },
                            { value: 2, label: '2 wks' },
                            { value: 3, label: '3 wks' },
                            { value: 4, label: '4 wks' }
                          ].map(option => (
                            <button
                              key={option.value}
                              onClick={(e) => {
                                e.stopPropagation();
                                console.log(`Setting ${machine.name} retirement to ${option.value} weeks`);
                                setRetireWeeksState(prev => ({ ...prev, [machine.id]: option.value }));
                              }}
                              className={`px-3 py-2 rounded-lg text-sm font-medium transition-all ${
                                selectedWeeks === option.value
                                  ? 'bg-purple-600 text-white border-2 border-purple-400'
                                  : 'bg-slate-600 text-slate-300 border-2 border-slate-500 hover:bg-slate-500'
                              }`}
                            >
                              {option.label}
                            </button>
                          ))}
                        </div>
                      </div>
                      <button
                        onClick={(e) => {
                          e.stopPropagation();
                          console.log(`Retiring ${machine.name} (${machine.id}) for ${selectedWeeks} weeks`);
                          retireMachine(machine.id, selectedWeeks);
                        }}
                        className="bg-yellow-600 hover:bg-yellow-700 text-white px-4 py-3 rounded-lg text-sm font-bold"
                      >
                        Retire Machine ({selectedWeeks === 1 ? '1 wk' : `${selectedWeeks} wks`})
                      </button>
                    </>
                  ) : (
                    <div className="bg-slate-700/50 border border-slate-600 rounded-lg px-4 py-3 text-center">
                      <div className="text-xs text-slate-400 mb-1">Auto-restoration scheduled</div>
                      <div className="text-sm text-emerald-400 font-medium">
                        {retirementInfo?.returnDate?.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}
                      </div>
                    </div>
                  )}
                </div>
              </div>
            </div>
          );
        })}
      </div>
    );
  };

          <div className="space-y-6">
            {/* Add/Edit Form */}
            <div className="bg-slate-700/50 rounded-lg p-6 mb-6 border border-purple-500/30">
              <h4 className="text-lg font-bold text-purple-300 mb-4">
                {machineFormMode === 'add' ? '‚ûï Add New Machine' : '‚úèÔ∏è Edit Machine'}
              </h4>

              <div className="space-y-4">
                <div>
                  <label className="block text-sm font-medium mb-2 text-slate-300">
                    Machine ID {machineFormMode === 'add' && <span className="text-red-400">*</span>}
                  </label>
                  <input
                    type="text"
                    value={machineForm.id}
                    onChange={(e) => setMachineForm(prev => ({ ...prev, id: e.target.value }))}
                    disabled={machineFormMode === 'edit'}
                    placeholder="e.g., evangelion, gundam, dragonball"
                    className={`w-full bg-slate-700 border border-slate-600 rounded-lg px-4 py-2 text-white ${
                      machineFormMode === 'edit' ? 'opacity-50 cursor-not-allowed' : ''
                    }`}
                  />
                  <p className="text-xs text-slate-400 mt-1">
                    {machineFormMode === 'add' 
                      ? 'Lowercase letters, numbers, underscores only. Cannot be changed later.'
                      : 'Machine ID cannot be changed after creation'}
                  </p>
                </div>

                <div>
                  <label className="block text-sm font-medium mb-2 text-slate-300">
                    Display Name <span className="text-red-400">*</span>
                  </label>
                  <input
                    type="text"
                    value={machineForm.name}
                    onChange={(e) => setMachineForm(prev => ({ ...prev, name: e.target.value }))}
                    placeholder="e.g., Evangelion: Decisive Battle"
                    className="w-full bg-slate-700 border border-slate-600 rounded-lg px-4 py-2 text-white"
                  />
                </div>

                <div>
                  <label className="block text-sm font-medium mb-2 text-slate-300">Odds Settings</label>
                  <p className="text-xs text-slate-400 mb-3">
                    Click to cycle: Allowed (green) ‚Üí Never Allowed (red) ‚Üí Neutral (gray) ‚Üí Allowed
                  </p>
                  <div className="grid grid-cols-6 gap-3">
                    {[1, 2, 3, 4, 5, 6].map(setting => {
                      const isAllowed = machineForm.allowedOdds.includes(setting);
                      const isNever = machineForm.neverAllowed.includes(setting);
                      
                      return (
                        <button
                          key={setting}
                          onClick={() => toggleOddsSetting(setting)}
                          className={`px-4 py-3 rounded-lg font-bold text-white border-2 transition-all ${
                            isAllowed 
                              ? 'bg-green-600 border-green-400 hover:bg-green-700'
                              : isNever
                                ? 'bg-red-600 border-red-400 hover:bg-red-700'
                                : 'bg-slate-600 border-slate-500 hover:bg-slate-500'
                          }`}
                        >
                          Setting {setting}
                          {isAllowed && ' ‚úì'}
                          {isNever && ' ‚úó'}
                        </button>
                      );
                    })}
                  </div>
                </div>

                <div>
                  <label className="block text-sm font-medium mb-2 text-slate-300">Initial Setting</label>
                  <select
                    value={machineForm.initial}
                    onChange={(e) => setMachineForm(prev => ({ ...prev, initial: parseInt(e.target.value) }))}
                    className="w-full bg-slate-700 border border-slate-600 rounded-lg px-4 py-2 text-white"
                  >
                    {machineForm.allowedOdds.map(odd => (
                      <option key={odd} value={odd}>Setting {odd}</option>
                    ))}
                  </select>
                  <p className="text-xs text-slate-400 mt-1">Default odds setting when machine is first added</p>
                </div>

                <div className="flex gap-3 pt-4 border-t border-slate-600">
                  {machineFormMode === 'add' ? (
                    <button
                      onClick={handleAddMachine}
                      className="flex-1 bg-gradient-to-r from-green-600 to-emerald-600 hover:from-green-700 hover:to-emerald-700 text-white font-bold py-3 rounded-lg"
                    >
                      ‚úì Add Machine
                    </button>
                  ) : (
                    <>
                      <button
                        onClick={handleUpdateMachine}
                        className="flex-1 bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-700 hover:to-indigo-700 text-white font-bold py-3 rounded-lg"
                      >
                        ‚úì Update Machine
                      </button>
                      <button
                        onClick={resetForm}
                        className="bg-slate-600 hover:bg-slate-700 text-white font-bold py-3 px-6 rounded-lg"
                      >
                        Cancel
                      </button>
                    </>
                  )}
                </div>
              </div>
            </div>

            {/* Active User Machines */}
            <div className="mb-6">
              <h4 className="text-lg font-bold text-green-300 mb-3">‚úì Active Hall Machines ({registry.getUser().length})</h4>
              {registry.getUser().length === 0 ? (
                <div className="text-center py-8 bg-slate-700/30 rounded-lg border border-slate-600">
                  <p className="text-slate-400">No custom machines yet. Add one above!</p>
                </div>
              ) : (
                <div className="space-y-3">
                  {registry.getUser().map(machine => (
                    <div key={machine.id} className="bg-slate-700/50 rounded-lg p-4 border border-green-500/30">
                      <div className="flex justify-between items-start mb-2">
                        <div>
                          <h5 className="text-lg font-bold text-white">{machine.name}</h5>
                          <p className="text-xs text-slate-400">ID: {machine.id}</p>
                        </div>
                        <div className="flex gap-2">
                          <button
                            onClick={() => startEdit(machine)}
                            className="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded text-sm font-medium"
                          >
                            Edit
                          </button>
                          <button
                            onClick={() => handleDeactivate(machine.id)}
                            className="bg-yellow-600 hover:bg-yellow-700 text-white px-3 py-1 rounded text-sm font-medium"
                          >
                            Deactivate
                          </button>
                        </div>
                      </div>
                      <div className="text-sm text-slate-300">
                        <span className="text-green-400">Allowed:</span> {machine.allowedOdds.join(', ')}
                        {' ‚Ä¢ '}
                        <span className="text-red-400">Never:</span> {machine.neverAllowed.join(', ')}
                        {' ‚Ä¢ '}
                        <span className="text-blue-400">Initial:</span> {machine.initial}
                      </div>
                    </div>
                  ))}
                </div>
              )}
            </div>

            {/* System Machines */}
            <div className="mb-6">
              <h4 className="text-lg font-bold text-blue-300 mb-3">üîí System Machines ({registry.getSystem().length})</h4>
              <div className="bg-blue-900/20 border border-blue-500/30 rounded-lg p-4">
                <p className="text-sm text-blue-200 mb-3">Built-in machines (cannot be edited or removed)</p>
                <div className="grid grid-cols-2 md:grid-cols-3 gap-2">
                  {registry.getSystem().map(machine => (
                    <div key={machine.id} className="text-sm text-slate-300 bg-slate-700/30 rounded px-3 py-2">
                      {machine.name}
                    </div>
                  ))}
                </div>
              </div>
            </div>

            {/* Inactive Machines */}
            {registry.getInactive().length > 0 && (
              <div>
                <h4 className="text-lg font-bold text-yellow-300 mb-3">üì¶ Inactive Machines ({registry.getInactive().length})</h4>
                <p className="text-sm text-slate-400 mb-3">
                  These machines are hidden but can be reactivated. Historical data is preserved.
                </p>
                <div className="space-y-3">
                  {registry.getInactive().map(machine => (
                    <div key={machine.id} className="bg-slate-700/50 rounded-lg p-4 border border-yellow-500/30 opacity-60">
                      <div className="flex justify-between items-start">
                        <div>
                          <h5 className="text-lg font-bold text-white">{machine.name}</h5>
                          <p className="text-xs text-slate-400">ID: {machine.id}</p>
                          {machine.deactivatedAt && (
                            <p className="text-xs text-yellow-400 mt-1">
                              Deactivated: {new Date(machine.deactivatedAt).toLocaleDateString()}
                            </p>
                          )}
                        </div>
                        <button
                          onClick={() => handleReactivate(machine.id)}
                          className="bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded text-sm font-medium"
                        >
                          Reactivate
                        </button>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>

  return (
    <div className={`min-h-screen ${isNightMode ? 'bg-gradient-to-br from-slate-950 via-purple-950 to-slate-950' : 'bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900'} text-white p-4 transition-colors duration-1000`}>
      {isLoading ? (
        <div className="fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center z-50">
          <div className="bg-gradient-to-br from-purple-900 to-slate-900 rounded-lg p-8 border-2 border-purple-500/40 shadow-2xl">
            <div className="flex flex-col items-center gap-4">
              <div className="w-16 h-16 border-4 border-purple-500/30 border-t-purple-500 rounded-full animate-spin"></div>
              <div className="text-2xl font-bold text-purple-300">Loading Data...</div>
              <div className="text-sm text-slate-400">Please wait</div>
            </div>
          </div>
        </div>
      ) : null}
      
      <div className="max-w-7xl mx-auto">
        <div className={`${isNightMode ? 'bg-slate-900/70' : 'bg-slate-800/50'} backdrop-blur rounded-lg p-6 mb-6 border border-purple-500/20 transition-colors duration-1000`}>
          <div className="flex justify-between items-start">
            <div className="flex-1">
              <div className="flex items-center gap-3">
                <h1 className="text-4xl font-bold bg-gradient-to-r from-purple-400 to-pink-400 bg-clip-text text-transparent">
                  {hallName}
                </h1>
                <button
                  onClick={() => {
                    setTempHallName(hallName);
                    setShowNameEditor(true);
                  }}
                  className="text-purple-400 hover:text-purple-300 transition-colors"
                  title="Edit hall name"
                >
                  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15.232 5.232l3.536 3.536m-2.036-5.036a2.5 2.5 0 113.536 3.536L6.5 21.036H3v-3.572L16.732 3.732z" />
                  </svg>
                </button>
              </div>
              <p className="text-slate-300">Pachislot Parlour Management System</p>
            </div>
            <div className="flex items-center gap-2">
              {isNightMode ? (
                <Moon className="text-purple-400" size={32} />
              ) : (
                <Sun className="text-yellow-400" size={32} />
              )}
              <div className="text-right">
                <div className="text-sm text-slate-400">
                  {isNightMode ? 'Night Mode' : 'Day Mode'}
                </div>
                <div className="text-xs text-slate-500">
                  {isNightMode ? '6 PM - 6 AM' : '6 AM - 6 PM'}
                </div>
              </div>
            </div>
          </div>
        </div>

        {/* Hall Name Editor Modal */}
        {showNameEditor && (
          <div 
            className="fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center z-50 p-4"
            onClick={(e) => {
              if (e.target === e.currentTarget) {
                setShowNameEditor(false);
              }
            }}
          >
            <div className={`${isNightMode ? 'bg-slate-900' : 'bg-slate-800'} rounded-lg p-8 max-w-lg w-full border-2 border-purple-500/40 shadow-2xl`}>
              <h3 className="text-2xl font-bold mb-4 text-purple-300">Edit Hall Name</h3>
              
              <div className="mb-6">
                <label className="block text-sm font-medium mb-2 text-slate-300">
                  Hall Name
                </label>
                <input
                  type="text"
                  value={tempHallName}
                  onChange={(e) => setTempHallName(e.target.value)}
                  placeholder="Enter your hall name"
                  className="w-full bg-slate-700 border border-slate-600 rounded-lg px-4 py-3 text-white text-lg"
                  autoFocus
                  onKeyDown={(e) => {
                    if (e.key === 'Enter') {
                      const newName = tempHallName.trim() || 'Project A Hall Tracker';
                      setHallName(newName);
                      window.storage.set('parlour-hall-name', newName)
                        .catch(err => console.error('Error saving hall name:', err));
                      setShowNameEditor(false);
                    }
                  }}
                />
                <p className="text-xs text-slate-400 mt-2">
                  This name will appear at the top of your tracker and in exports
                </p>
              </div>

              <div className="flex gap-3">
                <button
                  onClick={() => setShowNameEditor(false)}
                  className="flex-1 bg-slate-600 hover:bg-slate-700 text-white font-bold py-3 rounded-lg"
                >
                  Cancel
                </button>
                <button
                  onClick={async () => {
                    const newName = tempHallName.trim() || 'Project A Hall Tracker';
                    setHallName(newName);
                    try {
                      await window.storage.set('parlour-hall-name', newName);
                      setShowNameEditor(false);
                      alert('Hall name saved!');
                    } catch (error) {
                      alert('Error saving hall name: ' + error.message);
                    }
                  }}
                  className="flex-1 bg-gradient-to-r from-purple-600 to-pink-600 hover:from-purple-700 hover:to-pink-700 text-white font-bold py-3 rounded-lg"
                >
                  Save
                </button>
              </div>
            </div>
          </div>
        )}

        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
          <div className={`${isNightMode ? 'bg-slate-900/70' : 'bg-slate-800/50'} backdrop-blur rounded-lg p-6 border border-purple-500/20 transition-colors duration-1000`}>
            <div className="text-center">
              <div className="text-sm text-slate-400 mb-2">Current Date & Time</div>
              <div className="text-2xl font-bold mb-1 text-purple-300">{formatCurrentDateTime().time}</div>
              <div className="text-lg text-slate-300">{formatCurrentDateTime().date}</div>
            </div>
          </div>
          
          <div className={`${isNightMode ? 'bg-slate-900/70' : 'bg-slate-800/50'} backdrop-blur rounded-lg p-6 border border-purple-500/20 transition-colors duration-1000`}>
            <div className="text-center">
              <div className="text-sm text-slate-400 mb-2">Hall Status</div>
              <div className={`text-3xl font-bold mb-3 ${getHallStatus().statusColor}`}>
                {getHallStatus().statusText}
              </div>
              <div className={`text-lg font-medium ${getHallStatus().trafficColor}`}>
                {getHallStatus().trafficText}
              </div>
            </div>
          </div>
        </div>

        {/* Hanabi Swap Notification */}
        {hanabiSwapMessage && (
          <div className="bg-gradient-to-r from-yellow-600/30 to-orange-600/30 backdrop-blur rounded-lg p-6 mb-6 border-2 border-yellow-500/60 animate-pulse">
            <div className="flex items-start gap-4">
              <div className="text-4xl">üé∞</div>
              <div className="flex-1">
                <h3 className="text-2xl font-bold text-yellow-300 mb-2">Panel Swap Complete!</h3>
                <p className="text-xl text-yellow-100 font-medium">{hanabiSwapMessage}</p>
                <button
                  onClick={() => setHanabiSwapMessage(null)}
                  className="mt-4 bg-yellow-600/40 hover:bg-yellow-600/60 text-yellow-100 font-medium px-4 py-2 rounded-lg text-sm"
                >
                  Dismiss
                </button>
              </div>
            </div>
          </div>
        )}

        {isTwoHoursBeforeClosing() && (
          <div className="bg-gradient-to-r from-orange-600/30 to-red-600/30 backdrop-blur rounded-lg p-6 mb-6 border-2 border-orange-500/60 animate-pulse">
            <div className="flex items-start gap-4">
              <div className="text-4xl">‚ö†Ô∏è</div>
              <div className="flex-1">
                <h3 className="text-xl font-bold text-orange-300 mb-2">Daily Stats Reminder - End of Day</h3>
                <div className="space-y-2 text-orange-100">
                  <p className="font-medium">üìä Please complete the following tasks:</p>
                  <ul className="list-disc list-inside space-y-1 ml-2">
                    <li>Input latest accumulated stats for all machines</li>
                    <li>Calculate and save differences in the Accumulation Calculator</li>
                    <li>Navigate to Calendar tab and capture yesterday's stats snapshot</li>
                    <li>Click "Save Data" button to persist all changes</li>
                  </ul>
                </div>
              </div>
            </div>
          </div>
        )}

        {/* Closing warnings removed - 24/7 operation */}

        <div className={`${isNightMode ? 'bg-slate-900/70' : 'bg-slate-800/50'} backdrop-blur rounded-lg p-4 mb-6 border border-purple-500/20 transition-colors duration-1000`}>
          <div className="text-center">
            <div className="text-sm text-slate-400 mb-2">Current Period (Auto-Updated)</div>
            <div className="text-2xl font-bold text-purple-300">
              Cycle {currentCycle} (Month {currentCycle}) - Week {currentWeek}
            </div>
            <div className="text-xs text-slate-500 mt-2">
              {currentWeek === 1 && 'Days 1-7'}
              {currentWeek === 2 && 'Days 8-14'}
              {currentWeek === 3 && 'Days 15-21'}
              {currentWeek === 4 && 'Days 22+'}
            </div>
          </div>
        </div>

        <div className={`bg-gradient-to-r from-green-600/20 to-emerald-600/20 backdrop-blur rounded-lg p-4 mb-6 border border-green-500/40 transition-colors duration-1000 ${isNightMode ? 'opacity-90' : ''}`}>
          <div className="flex justify-between items-center mb-3">
            <h3 className="text-lg font-bold text-green-300">Available Machines</h3>
          </div>
          {!isHallOpen() ? (
            <div className="text-center py-8">
              <p className="text-gray-400 text-lg font-medium">üîí Hall Closed</p>
              <p className="text-gray-500 text-sm mt-2">All machines offline for maintenance</p>
            </div>
          ) : availableMachines.length === 0 ? (
            <div className="text-center py-8">
              <p className="text-slate-300 text-sm mb-4">üé∞ No machines available yet</p>
              <p className="text-slate-500 text-xs mb-4">Loading machine availability for this hour...</p>
              <button
                onClick={async () => {
                  try {
                    console.log('üîÑ Manual refresh triggered - FORCING new plan generation');
                    console.log('üé∞ Available machines in registry:', registry.getActive().length);
                    console.log('üé∞ Active Hanabi variant:', activeHanabiVariant);
                    console.log('üìä Current popularity values:', machinePopularity);
                    
                    const now = new Date();
                    const dateKey = `${now.getFullYear()}-${now.getMonth()}-${now.getDate()}`;
                    
                    // Wait for registry to be ready
                    if (registry.getActive().length === 0) {
                      alert('Error: No machines available in registry. Please add machines first.');
                      return;
                    }
                    
                    // ALWAYS generate a fresh plan with current popularity
                    console.log('üìÖ Generating fresh plan with current popularity...');
                    const plan = generateDayPlan(now);
                    console.log('‚úÖ Generated plan with', plan.hourlySchedule.length, 'hours');
                    
                    // Load existing plans and update with new plan
                    let storedPlans = {};
                    try {
                      const plansData = await window.storage.get('parlour-predetermined-days');
                      if (plansData) {
                        storedPlans = JSON.parse(plansData.value);
                      }
                    } catch (error) {
                      console.error('Error loading stored plans:', error);
                    }
                    
                    storedPlans[dateKey] = plan;
                    
                    try {
                      await window.storage.set('parlour-predetermined-days', JSON.stringify(storedPlans));
                      console.log('‚úÖ Saved fresh plan to storage');
                    } catch (error) {
                      console.error('Error saving plan:', error);
                      alert('Error saving plan: ' + error.message);
                      return;
                    }
                    
                    setPreDeterminedDays(storedPlans);
                    setCurrentDayPlan(plan);
                    setDayPlanLoaded(true);
                    
                    const currentHour = now.getHours();
                    console.log('‚è∞ Current hour:', currentHour);
                    
                    const currentHourPlan = plan.hourlySchedule.find(h => h.hour === currentHour);
                    
                    if (currentHourPlan) {
                      console.log(`‚úÖ Found plan for hour ${currentHour}`);
                      console.log(`üé∞ Available machines:`, currentHourPlan.availableMachines);
                      console.log(`üìä Available count:`, currentHourPlan.availableCount);
                      
                      setAvailableMachines(currentHourPlan.availableMachines);
                      setCurrentAvailableCount(currentHourPlan.availableCount);
                      
                      alert(`‚úÖ Generated fresh plan with current popularity!\n\nLoaded ${currentHourPlan.availableMachines.length} machines for hour ${currentHour}`);
                    } else {
                      console.error('‚ùå No plan for current hour');
                      alert(`Error: No schedule found for hour ${currentHour}. Plan has ${plan.hourlySchedule.length} hours.`);
                    }
                  } catch (error) {
                    console.error('‚ùå Error in load machines:', error);
                    alert('Error loading machines: ' + error.message);
                  }
                }}
                className="bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-6 rounded-lg flex items-center justify-center gap-2 mx-auto"
              >
                üîÑ Load Machines
              </button>
            </div>
          ) : (
            <>
              <div className="grid grid-cols-3 gap-2">
                {[...availableMachines].sort((a, b) => {
                  const machineA = MACHINES.find(m => m.id === a);
                  const machineB = MACHINES.find(m => m.id === b);
                  return (machineA?.name || '').localeCompare(machineB?.name || '');
                }).map(machineId => {
                  const machine = MACHINES.find(m => m.id === machineId);
                  return (
                    <div key={machineId} className={`${isNightMode ? 'bg-slate-900/70' : 'bg-slate-800/50'} rounded-lg p-3 text-center transition-colors duration-1000`}>
                      <div className="font-medium text-green-400">{machine?.name}</div>
                                <div className="text-xs text-slate-400 mt-1">
                                  Popularity: {(() => {
                                    const rawScore = machinePopularity[machineId] || 0.50;
                                    const normalizedScore = rawScore > 1 ? rawScore / 100 : rawScore;
                                    const percentage = Math.round(normalizedScore * 100);
                                    return `${percentage}%`;
                                  })()}
                                </div>
                    </div>
                  );
                })}
              </div>
              <p className="text-xs text-slate-400 mt-3">
                {getCurrentHoliday()?.name.includes('Golden Week') || getCurrentHoliday()?.name.includes('Silver Week')
                  ? `üéå ${getCurrentHoliday().name} - EXTREME traffic! Only ${getAvailableMachineCount()} machines available. Perfect time for Setting 6 promotions!`
                  : getCurrentHoliday()
                    ? `üéå ${getCurrentHoliday().name} - Increased holiday traffic! Only ${getAvailableMachineCount()} machines available.`
                    : `Available machines rotate hourly based on pre-determined traffic patterns. Currently ${getAvailableMachineCount()} machines available.`
                }
              </p>
            </>
          )}
        </div>

        <div className="flex gap-2 mb-6 overflow-x-auto">
          {['stats', 'machines', 'calendar', 'graphs', 'retirement'].map(tab => (
            <button
              key={tab}
              onClick={() => setActiveTab(tab)}
              className={`px-6 py-3 rounded-lg font-medium transition-all whitespace-nowrap ${
                activeTab === tab ? 'bg-purple-600 text-white' : 'bg-slate-700 text-slate-300 hover:bg-slate-600'
              }`}
            >
              {tab === 'stats' && 'Machine Stats'}
              {tab === 'machines' && 'Manage Machines'}
              {tab === 'calendar' && 'Calendar'}
              {tab === 'graphs' && 'Graphs'}
              {tab === 'retirement' && 'Retirement'}
            </button>
          ))}
        </div>

        {activeTab === 'stats' && (
          <div className="space-y-4">
            {[...MACHINES].sort((a, b) => a.name.localeCompare(b.name)).map(machine => {
              const totals = calculateTotals(machine.id);
              const isExpanded = expandedMachine === machine.id;
              const isAvailable = availableMachines.includes(machine.id);
              const isRetired = isMachineRetired(machine.id);
              const hallOpen = isHallOpen();
              
              return (
                <div key={machine.id} className={`${isNightMode ? 'bg-slate-900/70' : 'bg-slate-800/50'} backdrop-blur rounded-lg border overflow-hidden transition-colors duration-1000 ${
                  isRetired ? 'border-yellow-500/40 opacity-60' :
                  !hallOpen ? 'border-gray-500/40' :
                  isAvailable ? 'border-green-500/40' : 'border-red-500/40'
                }`}>
                  <div 
                    className="p-4 cursor-pointer hover:bg-slate-700/30"
                    onClick={() => !isRetired && setExpandedMachine(isExpanded ? null : machine.id)}
                  >
                    <div className="flex justify-between items-center">
                      <div className="flex-1">
                        <h3 className="text-xl font-bold text-purple-300">{machine.name}</h3>
                        {!isRetired && (
                          <div className="flex gap-4 mt-2 text-sm text-slate-400">
                            <span>Plays: {formatNumber(totals.total)}</span>
                            <span>Payout: {totals.payout}%</span>
                          </div>
                        )}
                      </div>
                      <div className="flex items-center gap-3">
                        {!isRetired && (isExpanded ? <ChevronUp /> : <ChevronDown />)}
                      </div>
                    </div>
                  </div>

                  {isExpanded && !isRetired && (
                    <div className={`p-4 border-t border-slate-700 space-y-6 ${isNightMode ? 'bg-slate-950/50' : ''} transition-colors duration-1000`}>
                      <div className="bg-gradient-to-r from-blue-900/30 to-purple-900/30 rounded-lg p-4 border border-blue-500/30">
                        <h4 className="text-lg font-bold text-blue-300 mb-3">üìä Enter Machine Counter Readings</h4>
                        <p className="text-sm text-slate-300 mb-4">Enter the accumulated totals shown on the machine's counter display.</p>
                        
                        <div className="mb-4 p-3 bg-yellow-900/30 border border-yellow-500/40 rounded-lg">
                          <label className="flex items-start gap-3 cursor-pointer">
                            <input
                              type="checkbox"
                              checked={accumulatedInputs[machine.id]?.skipCalculation || false}
                              onChange={(e) => setAccumulatedInput(machine.id, 'skipCalculation', e.target.checked)}
                              className="w-5 h-5 mt-0.5 flex-shrink-0"
                            />
                            <div>
                              <div className="text-sm font-bold text-yellow-300">Manual Entry Mode (Skip Calculation)</div>
                              <div className="text-xs text-yellow-200 mt-1">
                                Check this if odds were changed today. Values will be saved as-is without calculating differences.
                              </div>
                            </div>
                          </label>
                        </div>
                        
                        <div className="mb-4">
                          <label className="block text-sm font-medium mb-2 text-slate-300">Current Odds Setting</label>
                          <select
                            value={getSetting(machine.id)}
                            onChange={(e) => updateSetting(machine.id, e.target.value)}
                            className="w-full bg-slate-700 border border-slate-600 rounded-lg px-4 py-2 text-white"
                          >
                            {machine.allowedOdds.map(odd => (
                              <option key={odd} value={odd}>Setting {odd}</option>
                            ))}
                          </select>
                          <p className="text-xs text-slate-400 mt-1">
                            Allowed: {machine.allowedOdds.join(', ')} | Never: {machine.neverAllowed.join(', ')}
                          </p>
                        </div>
                        
                        <div className="space-y-3">
                          <div className="grid grid-cols-2 gap-3">
                            {['totalPlays', 'medalsIn', 'medalsOut', 'bbCount', 'rbCount'].map(field => (
                              <div key={field}>
                                <label className="block text-xs font-medium mb-1 text-slate-300">
                                  {field === 'totalPlays' ? 'Total Plays' :
                                   field === 'medalsIn' ? 'Medals In' :
                                   field === 'medalsOut' ? 'Medals Out' :
                                   field === 'bbCount' ? 'BB Count' :
                                   field === 'rbCount' ? 'RB Count' : field}
                                </label>
                                <input
                                  type="number"
                                  value={getAccumulatedInput(machine.id, field)}
                                  onChange={(e) => setAccumulatedInput(machine.id, field, e.target.value)}
                                  className="w-full bg-slate-700 border border-slate-600 rounded px-3 py-2 text-white text-sm"
                                  placeholder="0"
                                />
                              </div>
                            ))}
                          </div>
                          
                          <button
                            onClick={() => calculateAndSaveDifference(machine.id)}
                            className="w-full bg-gradient-to-r from-blue-600 to-purple-600 hover:from-blue-700 hover:to-purple-700 text-white font-bold py-3 rounded-lg"
                          >
                            üíæ Save Stats {accumulatedInputs[machine.id]?.skipCalculation ? '(Manual Mode)' : '(Auto Calculate)'}
                          </button>
                        </div>
                      </div>
                      
                      <div className="bg-slate-900/30 rounded-lg p-4 border border-slate-600">
                        <h4 className="text-sm font-bold text-slate-400 mb-3">Today</h4>
                        <div className="grid grid-cols-2 gap-3">
                          {['totalPlays', 'medalsIn', 'medalsOut', 'bbCount', 'rbCount'].map(field => (
                            <div key={field}>
                              <div className="text-xs text-slate-500">
                                {field === 'totalPlays' ? 'Total Plays' :
                                 field === 'medalsIn' ? 'Medals In' :
                                 field === 'medalsOut' ? 'Medals Out' :
                                 field === 'bbCount' ? 'BB Count' :
                                 field === 'rbCount' ? 'RB Count' : field}
                              </div>
                              <div className="text-lg font-bold text-white">{formatNumber(getStat(machine.id, field))}</div>
                            </div>
                          ))}
                          <div>
                            <label className="block text-xs mb-1 text-slate-300">Setting</label>
                            <select
                              value={getSetting(machine.id)}
                              onChange={(e) => updateSetting(machine.id, e.target.value)}
                              className="w-full bg-slate-700 border border-slate-600 rounded px-3 py-2 text-white"
                            >
                              {machine.allowedOdds.map(odd => (
                                <option key={odd} value={odd}>{odd}</option>
                              ))}
                            </select>
                          </div>
                        </div>
                      </div>
                      
                      <div className="bg-slate-900/30 rounded-lg p-4 border border-emerald-600/50">
                        <h4 className="text-sm font-bold text-emerald-400 mb-3">This Week (Monday-Sunday)</h4>
                        <div className="space-y-4">
                          {['totalPlays', 'medalsIn', 'medalsOut', 'bbCount', 'rbCount'].map(field => {
                            // Calculate current week totals by getting each day's activity
                            const today = new Date(currentTime);
                            const dayOfWeek = today.getDay(); // 0 = Sunday, 1 = Monday, etc.
                            
                            // Calculate Monday of this week
                            const mondayOffset = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
                            const monday = new Date(today);
                            monday.setDate(today.getDate() - mondayOffset);
                            monday.setHours(0, 0, 0, 0);
                            
                            const dayLabels = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
                            const dailyValues = [];
                            let weekTotal = 0;
                            
                            // Calculate how many days to show (up to today if before Sunday)
                            const daysToShow = dayOfWeek === 0 ? 7 : mondayOffset + 1;
                            
                            // Get each day's value
                            for (let i = 0; i < daysToShow; i++) {
                              const currentDay = new Date(monday);
                              currentDay.setDate(monday.getDate() + i);
                              
                              // Check if this is today
                              const isToday = currentDay.toDateString() === today.toDateString();
                              
                              let dayValue = 0;
                              if (isToday) {
                                // For today, use current "Today" stats
                                dayValue = getStat(machine.id, field) || 0;
                              } else {
                                // For past days, get from "Today" stats that were saved
                                const dayKey = `${currentDay.getFullYear()}-${currentDay.getMonth()}-${currentDay.getDate()}`;
                                const dayStats = calendarStats[dayKey];
                                if (dayStats && dayStats.machines && dayStats.machines[machine.id]) {
                                  // Calculate that day's activity
                                  const prevDay = new Date(currentDay);
                                  prevDay.setDate(currentDay.getDate() - 1);
                                  const prevDayKey = `${prevDay.getFullYear()}-${prevDay.getMonth()}-${prevDay.getDate()}`;
                                  const prevDayStats = calendarStats[prevDayKey];
                                  
                                  const todayReading = dayStats.machines[machine.id][field] || 0;
                                  const yesterdayReading = prevDayStats?.machines?.[machine.id]?.[field] || 0;
                                  dayValue = Math.max(0, todayReading - yesterdayReading);
                                }
                              }
                              
                              dailyValues.push(dayValue);
                              weekTotal += dayValue;
                            }
                            
                            return (
                              <div key={field} className="bg-slate-800/50 rounded p-3">
                                <div className="text-xs text-emerald-300 font-bold mb-2">
                                  {field === 'totalPlays' ? 'Total Plays' :
                                   field === 'medalsIn' ? 'Medals In' :
                                   field === 'medalsOut' ? 'Medals Out' :
                                   field === 'bbCount' ? 'BB Count' :
                                   field === 'rbCount' ? 'RB Count' : field}
                                </div>
                                <div className="grid grid-cols-7 gap-1 mb-2">
                                  {dailyValues.map((value, idx) => (
                                    <div key={idx} className="text-center">
                                      <div className="text-xs text-slate-500">{dayLabels[idx].substring(0, 3)}</div>
                                      <div className="text-sm font-bold text-white">{formatNumber(value)}</div>
                                    </div>
                                  ))}
                                  {/* Fill remaining days with dashes if week not complete */}
                                  {Array(7 - dailyValues.length).fill(0).map((_, idx) => (
                                    <div key={`empty-${idx}`} className="text-center">
                                      <div className="text-xs text-slate-500">{dayLabels[dailyValues.length + idx].substring(0, 3)}</div>
                                      <div className="text-sm font-bold text-slate-600">-</div>
                                    </div>
                                  ))}
                                </div>
                                <div className="pt-2 border-t border-emerald-600/30">
                                  <div className="flex justify-between items-center">
                                    <span className="text-xs text-emerald-300">Week Total:</span>
                                    <span className="text-lg font-bold text-white">{formatNumber(weekTotal)}</span>
                                  </div>
                                </div>
                              </div>
                            );
                          })}
                        </div>
                      </div>
                      
                      <div className="bg-slate-900/30 rounded-lg p-4 border border-emerald-600/50">
                        <h4 className="text-sm font-bold text-emerald-400 mb-3">Total Stats (All Time)</h4>
                        <div className="grid grid-cols-2 gap-3">
                          {['totalPlays', 'medalsIn', 'medalsOut', 'bbCount', 'rbCount'].map(field => {
                            const allTimeValue = allTimeStats[`${machine.id}-${field}`] || 0;
                            
                            return (
                              <div key={field}>
                                <div className="text-xs text-emerald-300">
                                  {field === 'totalPlays' ? 'Total Plays' :
                                   field === 'medalsIn' ? 'Medals In' :
                                   field === 'medalsOut' ? 'Medals Out' :
                                   field === 'bbCount' ? 'BB Count' :
                                   field === 'rbCount' ? 'RB Count' : field}
                                </div>
                                <div className="text-lg font-bold text-white">{formatNumber(allTimeValue)}</div>
                              </div>
                            );
                          })}
                        </div>
                      </div>
                      
                      <div className="bg-slate-900/30 rounded-lg p-4 border border-slate-600">
                        <h4 className="text-sm font-bold text-slate-400 mb-3">Graph Shape</h4>
                        <select
                          value={getAdjustment(machine.id, 'graph')}
                          onChange={(e) => updateAdjustment(machine.id, 'graph', e.target.value)}
                          className="w-full bg-slate-700 border border-slate-600 rounded-lg px-4 py-2 text-white"
                        >
                          <option value="">Select...</option>
                          {GRAPHS.map(g => <option key={g} value={g}>{g}</option>)}
                        </select>
                      </div>

                      <div className="bg-slate-900/30 rounded-lg p-4 border border-blue-600/50">
                        <h4 className="text-sm font-bold text-blue-400 mb-3">Machine Notes</h4>
                        <textarea
                          value={generalNotes[`${getPeriodKey()}-${machine.id}`] || ''}
                          onChange={(e) => setGeneralNotes(prev => ({...prev, [`${getPeriodKey()}-${machine.id}`]: e.target.value}))}
                          className="w-full bg-slate-700 border border-slate-600 rounded-lg px-4 py-3 text-white min-h-[100px] resize-y"
                          placeholder="Enter notes for this machine..."
                        />
                      </div>
                    </div>
                  )}
                </div>
              );
            })}

            <div className={`${isNightMode ? 'bg-slate-900/70' : 'bg-slate-800/50'} rounded-lg p-6 border border-purple-500/20 transition-colors duration-1000 mt-6`}>
              <h3 className="text-xl font-bold mb-4 text-purple-300">Designated Loser</h3>
              
              <div className="mb-6 p-4 bg-gradient-to-r from-red-900/30 to-orange-900/30 rounded-lg border border-red-500/40">
                <h4 className="text-lg font-bold text-red-300 mb-3">‚ö†Ô∏è Operator Rules</h4>
                <div className="space-y-3 text-sm text-slate-200">
                  <p className="leading-relaxed">
                    Every parlour has a <strong className="text-red-300">"Designated Loser"</strong> that becomes infamous for being a financial and emotional roller coaster.
                  </p>
                  
                  <div className="bg-slate-900/40 rounded p-3 border border-red-500/30">
                    <p className="font-bold text-red-300 mb-2">Core Rules:</p>
                    <ul className="list-disc list-inside space-y-1 ml-2">
                      <li>The Designated Loser rides on an <strong>odds setting of 1</strong></li>
                      <li>Can be switched to <strong>6 for a short period</strong> (such as an afternoon), <strong>very rarely</strong></li>
                      <li><strong className="text-orange-300">Never let the 6 run too long</strong> - set it back to 1 immediately after</li>
                      <li>Cannot be rotated from 1/6 too often - just <strong>rarely</strong> to add excitement and rage to the floor</li>
                    </ul>
                  </div>

                  <div className="bg-slate-900/40 rounded p-3 border border-red-500/30">
                    <p className="font-bold text-red-300 mb-2">Machine Selection Criteria:</p>
                    <ul className="list-disc list-inside space-y-1 ml-2">
                      <li>‚úì Must be <strong>visibly bad/overdone/unattractive</strong></li>
                      <li>‚úì Must <strong>absorb frustration</strong></li>
                      <li>‚úì Should <strong>not be a fan favourite</strong></li>
                    </ul>
                  </div>
                </div>
              </div>

              <select
                value={designatedLosers[getPeriodKey()] || ''}
                onChange={(e) => setDesignatedLosers(prev => ({...prev, [getPeriodKey()]: e.target.value}))}
                className="w-full bg-slate-700 border border-slate-600 rounded-lg px-4 py-2 text-white"
              >
                <option value="">None</option>
                {MACHINES.map(m => <option key={m.id} value={m.id}>{m.name}</option>)}
              </select>
            </div>

            <div className={`bg-gradient-to-r from-purple-600/20 to-pink-600/20 backdrop-blur rounded-lg p-6 border border-purple-500/40 transition-colors duration-1000 ${isNightMode ? 'opacity-90' : ''}`}>
              <h3 className="text-2xl font-bold mb-4 text-purple-300">Combined Totals (Today)</h3>
              <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                <div className={`${isNightMode ? 'bg-slate-900/70' : 'bg-slate-800/50'} rounded-lg p-3 transition-colors duration-1000`}>
                  <div className="text-sm text-slate-400">Total Plays</div>
                  <div className="text-2xl font-bold">{formatNumber(currentPeriodTotals.totalPlays)}</div>
                </div>
                <div className="bg-slate-800/50 rounded-lg p-3">
                  <div className="text-sm text-slate-400">Medals In</div>
                  <div className="text-2xl font-bold">{formatNumber(currentPeriodTotals.medalsIn)}</div>
                </div>
                <div className="bg-slate-800/50 rounded-lg p-3">
                  <div className="text-sm text-slate-400">Medals Out</div>
                  <div className="text-2xl font-bold">{formatNumber(currentPeriodTotals.medalsOut)}</div>
                </div>
                <div className="bg-slate-800/50 rounded-lg p-3">
                  <div className="text-sm text-slate-400">Payout %</div>
                  <div className="text-2xl font-bold">{currentPeriodTotals.payout}%</div>
                </div>
                <div className="bg-slate-800/50 rounded-lg p-3">
                  <div className="text-sm text-slate-400">BB Count</div>
                  <div className="text-2xl font-bold">{formatNumber(currentPeriodTotals.bbCount)}</div>
                </div>
                <div className="bg-slate-800/50 rounded-lg p-3">
                  <div className="text-sm text-slate-400">RB Count</div>
                  <div className="text-2xl font-bold">{formatNumber(currentPeriodTotals.rbCount)}</div>
                </div>
              </div>
            </div>

            <div className={`bg-gradient-to-r from-emerald-600/20 to-green-600/20 backdrop-blur rounded-lg p-6 border border-emerald-500/40 transition-colors duration-1000 ${isNightMode ? 'opacity-90' : ''}`}>
              <h3 className="text-2xl font-bold mb-4 text-emerald-300">Combined Totals (All Time)</h3>
              <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                <div className={`${isNightMode ? 'bg-slate-900/70' : 'bg-slate-800/50'} rounded-lg p-3 transition-colors duration-1000`}>
                  <div className="text-sm text-slate-400">Total Plays</div>
                  <div className="text-2xl font-bold">{formatNumber(allTimeTotals.totalPlays)}</div>
                </div>
                <div className="bg-slate-800/50 rounded-lg p-3">
                  <div className="text-sm text-slate-400">Medals In</div>
                  <div className="text-2xl font-bold">{formatNumber(allTimeTotals.medalsIn)}</div>
                </div>
                <div className="bg-slate-800/50 rounded-lg p-3">
                  <div className="text-sm text-slate-400">Medals Out</div>
                  <div className="text-2xl font-bold">{formatNumber(allTimeTotals.medalsOut)}</div>
                </div>
                <div className="bg-slate-800/50 rounded-lg p-3">
                  <div className="text-sm text-slate-400">Payout %</div>
                  <div className="text-2xl font-bold">{allTimeTotals.payout}%</div>
                </div>
                <div className="bg-slate-800/50 rounded-lg p-3">
                  <div className="text-sm text-slate-400">BB Count</div>
                  <div className="text-2xl font-bold">{formatNumber(allTimeTotals.bbCount)}</div>
                </div>
                <div className="bg-slate-800/50 rounded-lg p-3">
                  <div className="text-sm text-slate-400">RB Count</div>
                  <div className="text-2xl font-bold">{formatNumber(allTimeTotals.rbCount)}</div>
                </div>
              </div>
            </div>

            {/* Machine Popularity Rankings */}
            <div className={`bg-gradient-to-br from-indigo-600/20 to-purple-600/20 backdrop-blur rounded-lg p-6 border border-indigo-500/40 transition-colors duration-1000 ${isNightMode ? 'opacity-90' : ''}`}>
              <div className="mb-4">
                <h3 className="text-2xl font-bold text-indigo-300">üèÜ Machine Popularity Rankings</h3>
                <p className="text-sm text-slate-400 mt-1">
                  Based on Daily Performance Algorithm (Medals Out 32% ‚Ä¢ BB 33% ‚Ä¢ RB 20% ‚Ä¢ Play Volume 15%)
                </p>
                {popularityLastUpdated && (
                  <p className="text-xs text-slate-500 mt-1">
                    Last updated: {new Date(popularityLastUpdated).toLocaleString('en-US', { 
                      month: 'short', 
                      day: 'numeric', 
                      hour: '2-digit', 
                      minute: '2-digit',
                      hour12: true
                    })}
                  </p>
                )}
              </div>
              
              <div className="space-y-3">
                {sortedMachinesByPopularity.map((machine, index) => {
                  const rawPop = machinePopularity[machine.id] || 0.50;
                  const popularity = rawPop > 1 ? rawPop / 100 : rawPop;
                  const percentage = Math.round(popularity * 100);
                  
                  const allPopularities = MACHINES.map(m => {
                    const pop = machinePopularity[m.id] || 0.50;
                    return pop > 1 ? pop / 100 : pop;
                  });
                  const maxPopularity = Math.max(...allPopularities);
                  const barWidth = maxPopularity > 0 ? (popularity / maxPopularity) * 100 : 0;
                  
                  const isRetired = isMachineRetired(machine.id);
                  
                  return (
                    <div 
                      key={machine.id} 
                      className={`${isNightMode ? 'bg-slate-900/70' : 'bg-slate-800/50'} backdrop-blur rounded-lg p-4 border transition-colors duration-1000 ${
                        isRetired ? 'border-yellow-500/30 opacity-60' : 'border-indigo-500/30'
                      }`}
                    >
                      <div className="flex items-center justify-between mb-2">
                        <div className="flex items-center gap-3">
                          <span className="text-2xl font-bold text-indigo-400">#{index + 1}</span>
                          <div>
                            <span className="text-lg font-semibold text-white">{machine.name}</span>
                            {isRetired && (
                              <span className="ml-2 text-xs bg-yellow-600/40 text-yellow-200 px-2 py-1 rounded">
                                RETIRED
                              </span>
                            )}
                          </div>
                        </div>
                        <span className="text-2xl font-bold text-indigo-300">{percentage}%</span>
                      </div>
                      <div className="w-full bg-slate-700/50 rounded-full h-6 overflow-hidden">
                        <div 
                          className="h-full bg-gradient-to-r from-indigo-500 to-purple-500 rounded-full transition-all duration-500"
                          style={{ width: `${barWidth}%` }}
                        />
                      </div>
                    </div>
                  );
                })}
              </div>
            </div>
          </div>
        )}

        {activeTab === 'graphs' && (
          <div className="space-y-6">
            {/* Hall Traffic Graph */}
            <div className={`${isNightMode ? 'bg-slate-900/70' : 'bg-slate-800/50'} backdrop-blur rounded-lg p-6 border border-purple-500/20 transition-colors duration-1000`}>
              <h3 className="text-xl font-bold mb-4 text-purple-300">Hall Traffic & Occupancy (Live - Current Day)</h3>
              {(() => {
                const now = new Date(currentTime);
                const currentHour = now.getHours();
                
                // Check if we have a day plan loaded
                if (!currentDayPlan || !dayPlanLoaded) {
                  return (
                    <div className="text-center py-12">
                      <p className="text-slate-400 text-lg">üìä No day plan loaded yet</p>
                      <p className="text-slate-500 text-sm mt-2">Traffic graph will appear when hall opens and day plan loads</p>
                    </div>
                  );
                }
                
                // Filter to only show hours up to and including current hour
                const pastHours = currentDayPlan.hourlySchedule.filter(h => h.hour <= currentHour);
                
                if (pastHours.length === 0) {
                  return (
                    <div className="text-center py-12">
                      <p className="text-slate-400 text-lg">üìä No hours completed yet today</p>
                      <p className="text-slate-500 text-sm mt-2">Traffic graph will build progressively as the day progresses</p>
                    </div>
                  );
                }
                
                // Build graph data from past hours of the day plan
                const graphData = pastHours.map(hourPlan => ({
                  hour: hourPlan.hour,
                  availableCount: hourPlan.availableCount,
                  occupiedCount: MACHINES.length - hourPlan.availableCount,
                  occupancyRate: parseFloat(hourPlan.occupancyRate)
                }));
                
                return (
                  <>
                    <ResponsiveContainer width="100%" height={300}>
                      <LineChart data={graphData}>
                        <CartesianGrid strokeDasharray="3 3" stroke="#374151" />
                        <XAxis 
                          dataKey="hour" 
                          stroke="#9ca3af"
                          label={{ value: 'Hour of Day', position: 'insideBottom', offset: -5, fill: '#9ca3af' }}
                          domain={[
                            now.getDay() === 0 || now.getDay() === 6 ? 7 : 8,
                            currentHour
                          ]}
                          type="number"
                          tickFormatter={(hour) => `${hour}:00`}
                        />
                        <YAxis stroke="#9ca3af" />
                        <Tooltip 
                          contentStyle={{ backgroundColor: '#1e293b', border: '1px solid #4b5563' }}
                          labelFormatter={(hour) => `${hour}:00`}
                          formatter={(value, name) => {
                            if (name === 'Occupancy Rate') return `${value}%`;
                            return value;
                          }}
                        />
                        <Legend />
                        <Line type="monotone" dataKey="availableCount" stroke="#10b981" name="Available Machines" strokeWidth={2} />
                        <Line type="monotone" dataKey="occupiedCount" stroke="#ef4444" name="Occupied Machines" strokeWidth={2} />
                        <Line type="monotone" dataKey="occupancyRate" stroke="#a855f7" name="Occupancy Rate (%)" strokeWidth={3} />
                      </LineChart>
                    </ResponsiveContainer>
                    <p className="text-xs text-slate-400 mt-3">
                      üìä Traffic data from pre-determined day plan showing {pastHours.length} hour(s). Graph builds progressively throughout the day and will be saved when hall closes.
                    </p>
                  </>
                );
              })()}
            </div>

            {/* Overall Performance - Medals In/Out */}
            <div className={`${isNightMode ? 'bg-slate-900/70' : 'bg-slate-800/50'} backdrop-blur rounded-lg p-6 border border-purple-500/20 transition-colors duration-1000`}>
              <h3 className="text-xl font-bold mb-4 text-purple-300">Overall Medals In/Out Over Time</h3>
              <ResponsiveContainer width="100%" height={300}>
                <LineChart data={historicalData}>
                  <CartesianGrid strokeDasharray="3 3" stroke="#374151" />
                  <XAxis dataKey="period" stroke="#9ca3af" angle={-45} textAnchor="end" height={80} />
                  <YAxis stroke="#9ca3af" />
                  <Tooltip contentStyle={{ backgroundColor: '#1e293b', border: '1px solid #4b5563' }} />
                  <Legend />
                  <Line type="monotone" dataKey="medalsIn" stroke="#ef4444" name="Medals In" strokeWidth={2} />
                  <Line type="monotone" dataKey="medalsOut" stroke="#10b981" name="Medals Out" strokeWidth={2} />
                </LineChart>
              </ResponsiveContainer>
            </div>

            {/* Overall Payout % */}
            <div className={`${isNightMode ? 'bg-slate-900/70' : 'bg-slate-800/50'} backdrop-blur rounded-lg p-6 border border-purple-500/20 transition-colors duration-1000`}>
              <h3 className="text-xl font-bold mb-4 text-purple-300">Overall Payout % Over Time</h3>
              <ResponsiveContainer width="100%" height={300}>
                <LineChart data={historicalData}>
                  <CartesianGrid strokeDasharray="3 3" stroke="#374151" />
                  <XAxis dataKey="period" stroke="#9ca3af" angle={-45} textAnchor="end" height={80} />
                  <YAxis stroke="#9ca3af" />
                  <Tooltip contentStyle={{ backgroundColor: '#1e293b', border: '1px solid #4b5563' }} />
                  <Legend />
                  <Line type="monotone" dataKey="payout" stroke="#a855f7" name="Payout %" strokeWidth={3} />
                </LineChart>
              </ResponsiveContainer>
            </div>

            {/* Total Plays Graph */}
            <div className={`${isNightMode ? 'bg-slate-900/70' : 'bg-slate-800/50'} backdrop-blur rounded-lg p-6 border border-purple-500/20 transition-colors duration-1000`}>
              <h3 className="text-xl font-bold mb-4 text-purple-300">Total Plays Over Time</h3>
              <ResponsiveContainer width="100%" height={300}>
                <LineChart data={historicalData}>
                  <CartesianGrid strokeDasharray="3 3" stroke="#374151" />
                  <XAxis dataKey="period" stroke="#9ca3af" angle={-45} textAnchor="end" height={80} />
                  <YAxis stroke="#9ca3af" />
                  <Tooltip contentStyle={{ backgroundColor: '#1e293b', border: '1px solid #4b5563' }} />
                  <Legend />
                  <Line type="monotone" dataKey="totalPlays" stroke="#8b5cf6" name="Total Plays" strokeWidth={3} />
                </LineChart>
              </ResponsiveContainer>
            </div>

            {/* BB/RB Counts */}
            <div className={`${isNightMode ? 'bg-slate-900/70' : 'bg-slate-800/50'} backdrop-blur rounded-lg p-6 border border-purple-500/20 transition-colors duration-1000`}>
              <h3 className="text-xl font-bold mb-4 text-purple-300">Big Bonus & Regular Bonus Counts</h3>
              <ResponsiveContainer width="100%" height={300}>
                <LineChart data={historicalData}>
                  <CartesianGrid strokeDasharray="3 3" stroke="#374151" />
                  <XAxis dataKey="period" stroke="#9ca3af" angle={-45} textAnchor="end" height={80} />
                  <YAxis stroke="#9ca3af" />
                  <Tooltip contentStyle={{ backgroundColor: '#1e293b', border: '1px solid #4b5563' }} />
                  <Legend />
                  <Line type="monotone" dataKey="bbCount" stroke="#f59e0b" name="Big Bonus" strokeWidth={3} dot={{ r: 6 }} />
                  <Line type="monotone" dataKey="rbCount" stroke="#3b82f6" name="Regular Bonus" strokeWidth={3} dot={{ r: 6 }} />
                </LineChart>
              </ResponsiveContainer>
            </div>

            {/* Individual Machine Performance */}
            <div className={`bg-gradient-to-r from-purple-600/20 to-pink-600/20 backdrop-blur rounded-lg p-6 border border-purple-500/40 mt-8 transition-colors duration-1000 ${isNightMode ? 'opacity-90' : ''}`}>
              <h3 className="text-2xl font-bold mb-6 text-purple-300">Individual Machine Performance</h3>
              
              {MACHINES.map(machine => {
                const machineData = getMachineHistoricalData(machine.id);
                if (machineData.length === 0) return null;
                
                return (
                  <div key={machine.id} className="mb-12">
                    <h4 className="text-xl font-semibold mb-4 text-purple-300">{machine.name}</h4>
                    
                    {/* Machine Coins In/Out */}
                    <div className="mb-6">
                      <h5 className="text-sm font-medium mb-3 text-slate-400">Medals In/Out</h5>
                      <ResponsiveContainer width="100%" height={250}>
                        <LineChart data={machineData}>
                          <CartesianGrid strokeDasharray="3 3" stroke="#374151" />
                          <XAxis dataKey="period" stroke="#9ca3af" angle={-45} textAnchor="end" height={80} />
                          <YAxis stroke="#9ca3af" />
                          <Tooltip contentStyle={{ backgroundColor: '#1e293b', border: '1px solid #4b5563' }} />
                          <Legend />
                          <Line type="monotone" dataKey="medalsIn" stroke="#ef4444" name="Medals In" strokeWidth={2} />
                          <Line type="monotone" dataKey="medalsOut" stroke="#10b981" name="Medals Out" strokeWidth={2} />
                        </LineChart>
                      </ResponsiveContainer>
                    </div>

                    {/* Machine Payout % */}
                    <div className="mb-6">
                      <h5 className="text-sm font-medium mb-3 text-slate-400">Payout %</h5>
                      <ResponsiveContainer width="100%" height={250}>
                        <LineChart data={machineData}>
                          <CartesianGrid strokeDasharray="3 3" stroke="#374151" />
                          <XAxis dataKey="period" stroke="#9ca3af" angle={-45} textAnchor="end" height={80} />
                          <YAxis stroke="#9ca3af" />
                          <Tooltip contentStyle={{ backgroundColor: '#1e293b', border: '1px solid #4b5563' }} />
                          <Legend />
                          <Line type="monotone" dataKey="payout" stroke="#a855f7" name="Payout %" strokeWidth={3} />
                        </LineChart>
                      </ResponsiveContainer>
                    </div>

                    {/* Machine Total Plays */}
                    <div className="mb-6">
                      <h5 className="text-sm font-medium mb-3 text-slate-400">Total Plays</h5>
                      <ResponsiveContainer width="100%" height={250}>
                        <LineChart data={machineData}>
                          <CartesianGrid strokeDasharray="3 3" stroke="#374151" />
                          <XAxis dataKey="period" stroke="#9ca3af" angle={-45} textAnchor="end" height={80} />
                          <YAxis stroke="#9ca3af" />
                          <Tooltip contentStyle={{ backgroundColor: '#1e293b', border: '1px solid #4b5563' }} />
                          <Legend />
                          <Line type="monotone" dataKey="totalPlays" stroke="#8b5cf6" name="Total Plays" strokeWidth={3} />
                        </LineChart>
                      </ResponsiveContainer>
                    </div>

                    {/* Machine BB/RB Counts */}
                    <div className="mb-6">
                      <h5 className="text-sm font-medium mb-3 text-slate-400">Bonus Counts</h5>
                      <ResponsiveContainer width="100%" height={250}>
                        <LineChart data={machineData}>
                          <CartesianGrid strokeDasharray="3 3" stroke="#374151" />
                          <XAxis dataKey="period" stroke="#9ca3af" angle={-45} textAnchor="end" height={80} />
                          <YAxis stroke="#9ca3af" />
                          <Tooltip contentStyle={{ backgroundColor: '#1e293b', border: '1px solid #4b5563' }} />
                          <Legend />
                          <Line type="monotone" dataKey="bbCount" stroke="#f59e0b" name="Big Bonus" strokeWidth={3} dot={{ r: 6 }} />
                          <Line type="monotone" dataKey="rbCount" stroke="#3b82f6" name="Regular Bonus" strokeWidth={3} dot={{ r: 6 }} />
                        </LineChart>
                      </ResponsiveContainer>
                    </div>

                    <div className="border-t border-slate-700 mt-8"></div>
                  </div>
                );
              })}
            </div>
          </div>
        )}



        {activeTab === 'retirement' && <RetirementTab />}

        {activeTab === 'machines' && (
          <div className="space-y-6">
            <div className={`bg-gradient-to-br from-purple-600/20 to-pink-600/20 backdrop-blur rounded-lg p-6 border border-purple-500/40 transition-colors duration-1000 ${isNightMode ? 'opacity-90' : ''}`}>
              <h3 className="text-2xl font-bold mb-2 text-purple-300">üé∞ Machine Management</h3>
              <p className="text-slate-300 mb-4">
                Add custom pachislot machines to your hall. Define odds settings, initial configurations, and manage your entire machine lineup.
              </p>
            </div>

            {/* Add/Edit Form */}
            <div className="bg-slate-700/50 rounded-lg p-6 mb-6 border border-purple-500/30">
              <h4 className="text-lg font-bold text-purple-300 mb-4">
                {machineFormMode === 'add' ? '‚ûï Add New Machine' : '‚úèÔ∏è Edit Machine'}
              </h4>

              <div className="space-y-4">
                <div>
                  <label className="block text-sm font-medium mb-2 text-slate-300">
                    Machine ID {machineFormMode === 'add' && <span className="text-red-400">*</span>}
                  </label>
                  <input
                    type="text"
                    value={machineForm.id}
                    onChange={(e) => setMachineForm(prev => ({ ...prev, id: e.target.value }))}
                    disabled={machineFormMode === 'edit'}
                    placeholder="e.g., evangelion, gundam, dragonball"
                    className={`w-full bg-slate-700 border border-slate-600 rounded-lg px-4 py-2 text-white ${
                      machineFormMode === 'edit' ? 'opacity-50 cursor-not-allowed' : ''
                    }`}
                  />
                  <p className="text-xs text-slate-400 mt-1">
                    {machineFormMode === 'add' 
                      ? 'Lowercase letters, numbers, underscores only. Cannot be changed later.'
                      : 'Machine ID cannot be changed after creation'}
                  </p>
                </div>

                <div>
                  <label className="block text-sm font-medium mb-2 text-slate-300">
                    Display Name <span className="text-red-400">*</span>
                  </label>
                  <input
                    type="text"
                    value={machineForm.name}
                    onChange={(e) => setMachineForm(prev => ({ ...prev, name: e.target.value }))}
                    placeholder="e.g., Evangelion: Decisive Battle"
                    className="w-full bg-slate-700 border border-slate-600 rounded-lg px-4 py-2 text-white"
                  />
                </div>

                <div>
                  <label className="block text-sm font-medium mb-2 text-slate-300">Odds Settings</label>
                  <p className="text-xs text-slate-400 mb-3">
                    Click to cycle: Allowed (green) ‚Üí Never Allowed (red) ‚Üí Neutral (gray) ‚Üí Allowed
                  </p>
                  <div className="grid grid-cols-3 gap-3">
                    {[1, 2, 3, 4, 5, 6].map(setting => {
                      const isAllowed = machineForm.allowedOdds.includes(setting);
                      const isNever = machineForm.neverAllowed.includes(setting);
                      
                      return (
                        <button
                          key={setting}
                          onClick={() => toggleOddsSetting(setting)}
                          className={`px-4 py-3 rounded-lg font-bold text-white border-2 transition-all ${
                            isAllowed 
                              ? 'bg-green-600 border-green-400 hover:bg-green-700'
                              : isNever
                                ? 'bg-red-600 border-red-400 hover:bg-red-700'
                                : 'bg-slate-600 border-slate-500 hover:bg-slate-500'
                          }`}
                        >
                          Setting {setting}
                          {isAllowed && ' ‚úì'}
                          {isNever && ' ‚úó'}
                        </button>
                      );
                    })}
                  </div>
                </div>

                <div>
                  <label className="block text-sm font-medium mb-2 text-slate-300">Initial Setting</label>
                  <select
                    value={machineForm.initial}
                    onChange={(e) => setMachineForm(prev => ({ ...prev, initial: parseInt(e.target.value) }))}
                    className="w-full bg-slate-700 border border-slate-600 rounded-lg px-4 py-2 text-white"
                  >
                    {machineForm.allowedOdds.map(odd => (
                      <option key={odd} value={odd}>Setting {odd}</option>
                    ))}
                  </select>
                  <p className="text-xs text-slate-400 mt-1">Default odds setting when machine is first added</p>
                </div>

                <div className="flex gap-3 pt-4 border-t border-slate-600">
                  {machineFormMode === 'add' ? (
                    <button
                      onClick={handleAddMachine}
                      className="flex-1 bg-gradient-to-r from-green-600 to-emerald-600 hover:from-green-700 hover:to-emerald-700 text-white font-bold py-3 rounded-lg"
                    >
                      ‚úì Add Machine
                    </button>
                  ) : (
                    <>
                      <button
                        onClick={handleUpdateMachine}
                        className="flex-1 bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-700 hover:to-indigo-700 text-white font-bold py-3 rounded-lg"
                      >
                        ‚úì Update Machine
                      </button>
                      <button
                        onClick={resetForm}
                        className="bg-slate-600 hover:bg-slate-700 text-white font-bold py-3 px-6 rounded-lg"
                      >
                        Cancel
                      </button>
                    </>
                  )}
                </div>
              </div>
            </div>

            {/* Active User Machines */}
            <div className="mb-6">
              <h4 className="text-lg font-bold text-green-300 mb-3">‚úì Active Machines ({registry.getUser().length})</h4>
              {registry.getUser().length === 0 ? (
                <div className="text-center py-8 bg-slate-700/30 rounded-lg border border-slate-600">
                  <p className="text-slate-400">No custom machines yet. Add one above!</p>
                </div>
              ) : (
                <div className="space-y-3">
                  {registry.getUser().map(machine => (
                    <div key={machine.id} className="bg-slate-700/50 rounded-lg p-4 border border-green-500/30">
                      <div className="flex justify-between items-start mb-2">
                        <div>
                          <h5 className="text-lg font-bold text-white">{machine.name}</h5>
                          <p className="text-xs text-slate-400">ID: {machine.id}</p>
                        </div>
                        <div className="flex gap-2">
                          <button
                            onClick={() => startEdit(machine)}
                            className="bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded text-sm font-medium"
                          >
                            Edit
                          </button>
                        </div>
                      </div>
                      <div className="text-sm text-slate-300">
                        <span className="text-green-400">Allowed:</span> {machine.allowedOdds.join(', ')}
                        {' ‚Ä¢ '}
                        <span className="text-red-400">Never:</span> {machine.neverAllowed.join(', ')}
                        {' ‚Ä¢ '}
                        <span className="text-blue-400">Initial:</span> {machine.initial}
                      </div>
                    </div>
                  ))}
                </div>
              )}
            </div>

            {/* Active User Machines Preview */}
            {registry.getUser().length > 0 && (
              <div className={`${isNightMode ? 'bg-slate-900/70' : 'bg-slate-800/50'} rounded-lg p-6 border border-green-500/20`}>
                <h4 className="text-xl font-bold text-green-300 mb-4">Your Hall Machines</h4>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-3">
                  {registry.getUser().map(machine => (
                    <div key={machine.id} className="bg-slate-700/50 rounded-lg p-4 border border-green-500/20">
                      <div className="font-bold text-white mb-1">{machine.name}</div>
                      <div className="text-xs text-slate-400">
                        Allowed: {machine.allowedOdds.join(', ')} ‚Ä¢ Never: {machine.neverAllowed.join(', ')}
                      </div>
                      {machine.addedAt && (
                        <div className="text-xs text-slate-500 mt-1">
                          Added: {new Date(machine.addedAt).toLocaleDateString()}
                        </div>
                      )}
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>
        )}

        {activeTab === 'calendar' && (
          <div className="space-y-6">
            <div className={`bg-gradient-to-br from-purple-600/20 to-pink-600/20 backdrop-blur rounded-lg p-6 border border-purple-500/40 transition-colors duration-1000 ${isNightMode ? 'opacity-90' : ''}`}>
              <h3 className="text-2xl font-bold mb-2 text-purple-300">üìÖ Calendar</h3>
              <p className="text-slate-300">
                Navigate through months to see Japanese holidays and custom promotions. Click any day to add notes, capture stats, or create promotions.
              </p>
            </div>

            <div className={`${isNightMode ? 'bg-slate-900/70' : 'bg-slate-800/50'} backdrop-blur rounded-lg p-6 border border-purple-500/20 transition-colors duration-1000`}>
              <div className="flex justify-between items-center mb-6">
                <button
                  onClick={() => {
                    if (calendarMonth === 0) {
                      setCalendarMonth(11);
                      setCalendarYear(calendarYear - 1);
                    } else {
                      setCalendarMonth(calendarMonth - 1);
                    }
                  }}
                  className="bg-purple-600 hover:bg-purple-700 text-white px-4 py-2 rounded-lg font-medium"
                >
                  ‚Üê Previous
                </button>
                
                <div className="text-center">
                  <h4 className="text-2xl font-bold text-purple-300">
                    {['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'][calendarMonth]} {calendarYear}
                  </h4>
                  <button
                    onClick={() => {
                      setCalendarYear(currentTime.getFullYear());
                      setCalendarMonth(currentTime.getMonth());
                    }}
                    className="text-sm text-purple-400 hover:text-purple-300 underline mt-2"
                  >
                    Go to Today
                  </button>
                </div>
                
                <button
                  onClick={() => {
                    if (calendarMonth === 11) {
                      setCalendarMonth(0);
                      setCalendarYear(calendarYear + 1);
                    } else {
                      setCalendarMonth(calendarMonth + 1);
                    }
                  }}
                  className="bg-purple-600 hover:bg-purple-700 text-white px-4 py-2 rounded-lg font-medium"
                >
                  Next ‚Üí
                </button>
              </div>

              <div className="grid grid-cols-7 gap-2 mb-2">
                {['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].map(day => (
                  <div key={day} className="text-center font-bold text-purple-300 py-2">
                    {day}
                  </div>
                ))}
              </div>

              <div className="grid grid-cols-7 gap-2">
                {(() => {
                  const daysInMonth = new Date(calendarYear, calendarMonth + 1, 0).getDate();
                  const firstDayOfMonth = new Date(calendarYear, calendarMonth, 1).getDay();
                  const days = [];
                  
                  for (let i = 0; i < firstDayOfMonth; i++) {
                    days.push(<div key={`empty-${i}`} className="aspect-square" />);
                  }
                  
                  for (let day = 1; day <= daysInMonth; day++) {
                    const date = new Date(calendarYear, calendarMonth, day);
                    date.setHours(0, 0, 0, 0);
                    
                    const holiday = japaneseHolidays.find(h => {
                      const start = new Date(h.start);
                      const end = new Date(h.end);
                      start.setHours(0, 0, 0, 0);
                      end.setHours(23, 59, 59, 999);
                      return date >= start && date <= end;
                    });
                    
                    const customPromo = customPromotions.find(p => {
                      const promoDate = new Date(p.date);
                      return promoDate.getFullYear() === date.getFullYear() &&
                             promoDate.getMonth() === date.getMonth() &&
                             promoDate.getDate() === date.getDate();
                    });
                    
                    const dateKey = `${date.getFullYear()}-${date.getMonth()}-${date.getDate()}`;
                    const hasStats = calendarStats[dateKey] !== undefined;
                    const hasNotes = calendarNotes[dateKey] && calendarNotes[dateKey].trim() !== '';
                    const hasGraph = dailyTrafficGraphs[dateKey] && dailyTrafficGraphs[dateKey].length > 0;
                    
                    const isToday = date.getDate() === currentTime.getDate() && 
                                    date.getMonth() === currentTime.getMonth() && 
                                    date.getFullYear() === currentTime.getFullYear();
                    
                    const isPeakPeriod = holiday?.name.includes('Golden Week') || holiday?.name.includes('Silver Week');
                    
                    let borderColor = 'border-slate-600/30';
                    let bgColor = 'bg-slate-700/30';
                    let textColor = 'text-slate-300';
                    
                    if (isToday) {
                      borderColor = 'border-blue-500';
                      bgColor = 'bg-blue-600/30';
                      textColor = 'text-blue-200';
                    } else if (isPeakPeriod) {
                      borderColor = 'border-red-500/60';
                      bgColor = 'bg-red-600/30';
                      textColor = 'text-red-200';
                    } else if (holiday) {
                      borderColor = 'border-yellow-500/60';
                      bgColor = 'bg-yellow-600/30';
                      textColor = 'text-yellow-200';
                    } else if (customPromo) {
                      borderColor = 'border-purple-500/60';
                      bgColor = 'bg-purple-600/30';
                      textColor = 'text-purple-200';
                    }
                    
                    const isSelected = selectedDate && 
                                      selectedDate.getDate() === date.getDate() &&
                                      selectedDate.getMonth() === date.getMonth() &&
                                      selectedDate.getFullYear() === date.getFullYear();
                    
                    days.push(
                      <div
                        key={day}
                        onClick={() => setSelectedDate(date)}
                        className={`aspect-square rounded-lg p-2 border-2 transition-all cursor-pointer hover:ring-2 hover:ring-purple-400 ${borderColor} ${bgColor} ${
                          isSelected ? 'ring-4 ring-purple-500' :
                          isToday ? 'ring-2 ring-blue-400' : ''
                        }`}
                      >
                        <div className={`text-sm font-bold mb-1 ${textColor}`}>
                          {day}
                        </div>
                        
                        {/* Status Dots */}
                        <div className="flex gap-1 mb-1">
                          {hasStats && (
                            <div className="w-2 h-2 rounded-full bg-green-400" title="Stats saved"></div>
                          )}
                          {hasNotes && (
                            <div className="w-2 h-2 rounded-full bg-blue-400" title="Notes saved"></div>
                          )}
                          {hasGraph && (
                            <div className="w-2 h-2 rounded-full bg-purple-400" title="Traffic graph saved"></div>
                          )}
                        </div>
                        
                        {holiday && (
                          <div className={`text-xs font-medium leading-tight ${
                            isPeakPeriod ? 'text-red-300' : 'text-yellow-300'
                          }`}>
                            {isPeakPeriod && 'üî• '}
                            {holiday.name.length > 12 ? holiday.name.substring(0, 10) + '...' : holiday.name}
                          </div>
                        )}
                        
                        {customPromo && !holiday && (
                          <div className="text-xs font-medium leading-tight text-purple-300">
                            üéØ {customPromo.name.length > 10 ? customPromo.name.substring(0, 8) + '...' : customPromo.name}
                          </div>
                        )}
                      </div>
                    );
                  }
                  
                  return days;
                })()}
              </div>

              <div className="mt-6 pt-6 border-t border-slate-600/50">
                <h5 className="text-sm font-bold text-purple-300 mb-3">Legend:</h5>
                <div className="grid grid-cols-2 md:grid-cols-3 gap-3">
                  <div className="flex items-center gap-2">
                    <div className="w-6 h-6 rounded border-2 border-blue-500 bg-blue-600/30 ring-2 ring-blue-400" />
                    <span className="text-sm text-slate-300">Today</span>
                  </div>
                  <div className="flex items-center gap-2">
                    <div className="w-6 h-6 rounded border-2 border-red-500/60 bg-red-600/30" />
                    <span className="text-sm text-slate-300">Peak Holiday</span>
                  </div>
                  <div className="flex items-center gap-2">
                    <div className="w-6 h-6 rounded border-2 border-yellow-500/60 bg-yellow-600/30" />
                    <span className="text-sm text-slate-300">Public Holiday</span>
                  </div>
                  <div className="flex items-center gap-2">
                    <div className="w-6 h-6 rounded border-2 border-purple-500/60 bg-purple-600/30" />
                    <span className="text-sm text-slate-300">Custom Promotion</span>
                  </div>
                </div>
                <div className="mt-4 pt-4 border-t border-slate-600/50">
                  <h6 className="text-xs font-bold text-purple-300 mb-2">Status Indicators:</h6>
                  <div className="grid grid-cols-1 md:grid-cols-3 gap-2">
                    <div className="flex items-center gap-2">
                      <div className="w-3 h-3 rounded-full bg-green-400" />
                      <span className="text-xs text-slate-300">Stats Saved</span>
                    </div>
                    <div className="flex items-center gap-2">
                      <div className="w-3 h-3 rounded-full bg-blue-400" />
                      <span className="text-xs text-slate-300">Notes Saved</span>
                    </div>
                    <div className="flex items-center gap-2">
                      <div className="w-3 h-3 rounded-full bg-purple-400" />
                      <span className="text-xs text-slate-300">Traffic Graph Saved</span>
                    </div>
                  </div>
                  <p className="text-xs text-slate-400 mt-2 italic">
                    üí° Dots appear on calendar days when data is saved. Missing dots indicate data that hasn't been entered yet.
                  </p>
                </div>
              </div>
            </div>

            {selectedDate && (
              <div className={`${isNightMode ? 'bg-slate-900/70' : 'bg-slate-800/50'} backdrop-blur rounded-lg p-6 border border-purple-500/20 transition-colors duration-1000`}>
                <div className="flex justify-between items-start mb-4">
                  <h4 className="text-xl font-bold text-purple-300">
                    {selectedDate.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric', year: 'numeric' })}
                  </h4>
                  <button
                    onClick={() => setSelectedDate(null)}
                    className="text-slate-400 hover:text-white"
                  >
                    ‚úï
                  </button>
                </div>

                {/* Custom Promotion Section */}
                <div className="mb-6 p-4 bg-gradient-to-r from-pink-900/30 to-purple-900/30 rounded-lg border border-pink-500/30">
                  <h5 className="text-lg font-bold text-pink-300 mb-4">üéØ Custom Promotion</h5>
                  
                  {(() => {
                    const dateKey = `${selectedDate.getFullYear()}-${selectedDate.getMonth()}-${selectedDate.getDate()}`;
                    const existingPromo = customPromotions.find(p => {
                      const promoDate = new Date(p.date);
                      return promoDate.getFullYear() === selectedDate.getFullYear() &&
                             promoDate.getMonth() === selectedDate.getMonth() &&
                             promoDate.getDate() === selectedDate.getDate();
                    });

                    return (
                      <div className="space-y-3">
                        {existingPromo && (
                          <div className="mb-4 p-3 bg-pink-600/20 rounded border border-pink-500/40">
                            <div className="text-sm font-medium text-pink-200">‚úì Promotion Active</div>
                            <div className="text-xs text-pink-300 mt-1">Edit details below to update</div>
                          </div>
                        )}
                        
                        <div>
                          <label className="block text-sm font-medium mb-2 text-pink-200">Promotion Name</label>
                          <input
                            type="text"
                            value={promoName}
                            onChange={(e) => setPromoName(e.target.value)}
                            placeholder="e.g., Lucky 7s Weekend, Big Bonus Bonanza"
                            className="w-full bg-slate-700 border border-slate-600 rounded-lg px-4 py-2 text-white"
                          />
                        </div>

                        <div>
                          <label className="block text-sm font-medium mb-2 text-pink-200">Details</label>
                          <textarea
                            value={promoDetails}
                            onChange={(e) => setPromoDetails(e.target.value)}
                            placeholder="Describe the promotion (e.g., All machines set to Setting 6, Double BB rates)"
                            className="w-full bg-slate-700 border border-slate-600 rounded-lg px-4 py-3 text-white min-h-[100px]"
                          />
                        </div>

                        <div>
                          <label className="block text-sm font-medium mb-2 text-pink-200">Special Rules</label>
                          <textarea
                            value={promoRules}
                            onChange={(e) => setPromoRules(e.target.value)}
                            placeholder="Any special rules or conditions (e.g., Members only, Minimum ¬•1000 play)"
                            className="w-full bg-slate-700 border border-slate-600 rounded-lg px-4 py-3 text-white min-h-[80px]"
                          />
                        </div>

                        <div className="flex gap-3">
                          <button
                            onClick={async () => {
                              if (!promoName.trim()) {
                                alert('Please enter a promotion name');
                                return;
                              }

                              const promotion = {
                                date: selectedDate.toISOString(),
                                name: promoName,
                                details: promoDetails,
                                rules: promoRules
                              };

                              // Remove existing promotion for this date if any
                              const filtered = customPromotions.filter(p => {
                                const promoDate = new Date(p.date);
                                return !(promoDate.getFullYear() === selectedDate.getFullYear() &&
                                       promoDate.getMonth() === selectedDate.getMonth() &&
                                       promoDate.getDate() === selectedDate.getDate());
                              });

                              const updatedPromos = [...filtered, promotion];
                              setCustomPromotions(updatedPromos);

                              // Save immediately
                              try {
                                await window.storage.set('parlour-custom-promos', JSON.stringify(updatedPromos));
                                alert(`Promotion "${promoName}" saved for ${selectedDate.toLocaleDateString()}!`);
                              } catch (error) {
                                console.error('Error saving promotion:', error);
                                alert('Error saving promotion');
                              }
                            }}
                            className="flex-1 bg-gradient-to-r from-pink-600 to-purple-600 hover:from-pink-700 hover:to-purple-700 text-white font-bold py-3 rounded-lg"
                          >
                            {existingPromo ? 'üíæ Update Promotion' : '‚ûï Create Promotion'}
                          </button>

                          {existingPromo && (
                            <button
                              onClick={async () => {
                                if (!confirm('Delete this promotion?')) return;

                                const filtered = customPromotions.filter(p => {
                                  const promoDate = new Date(p.date);
                                  return !(promoDate.getFullYear() === selectedDate.getFullYear() &&
                                         promoDate.getMonth() === selectedDate.getMonth() &&
                                         promoDate.getDate() === selectedDate.getDate());
                                });

                                setCustomPromotions(filtered);
                                setPromoName('');
                                setPromoDetails('');
                                setPromoRules('');

                                try {
                                  await window.storage.set('parlour-custom-promos', JSON.stringify(filtered));
                                  alert('Promotion deleted');
                                } catch (error) {
                                  console.error('Error deleting promotion:', error);
                                }
                              }}
                              className="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg"
                            >
                              üóëÔ∏è Delete
                            </button>
                          )}
                        </div>
                      </div>
                    );
                  })()}
                </div>
                
                {/* Capture Stats Button */}
                <div className="mb-4">
                  <button
                    onClick={async () => {
                      const dateKey = `${selectedDate.getFullYear()}-${selectedDate.getMonth()}-${selectedDate.getDate()}`;
                      
                      // Capture each machine's current "Today" stats (these are the calculated activity for today)
                      const machineStats = {};
                      MACHINES.forEach(machine => {
                        machineStats[machine.id] = {
                          totalPlays: getStat(machine.id, 'totalPlays'),
                          medalsIn: getStat(machine.id, 'medalsIn'),
                          medalsOut: getStat(machine.id, 'medalsOut'),
                          bbCount: getStat(machine.id, 'bbCount'),
                          rbCount: getStat(machine.id, 'rbCount'),
                          setting: getSetting(machine.id)
                        };
                      });
                      
                      // Calculate combined totals for display
                      const currentTotals = calculateAllTotals();
                      
                      // UPDATE ALL-TIME STATS when capturing to calendar
                      const newAllTimeStats = { ...allTimeStats };
                      MACHINES.forEach(machine => {
                        const todayActivity = {
                          totalPlays: getStat(machine.id, 'totalPlays'),
                          medalsIn: getStat(machine.id, 'medalsIn'),
                          medalsOut: getStat(machine.id, 'medalsOut'),
                          bbCount: getStat(machine.id, 'bbCount'),
                          rbCount: getStat(machine.id, 'rbCount')
                        };
                        
                        ['totalPlays', 'medalsIn', 'medalsOut', 'bbCount', 'rbCount'].forEach(field => {
                          const currentAllTime = allTimeStats[`${machine.id}-${field}`] || 0;
                          const newTotal = currentAllTime + todayActivity[field];
                          newAllTimeStats[`${machine.id}-${field}`] = newTotal;
                        });
                      });
                      setAllTimeStats(newAllTimeStats);
                      
                      // Save all-time stats to storage
                      try {
                        await window.storage.set('parlour-alltime-stats', JSON.stringify(newAllTimeStats));
                      } catch (error) {
                        console.error('Error saving all-time stats:', error);
                      }
                      
                      // Copy traffic graph from current day plan (if available)
                      let trafficGraphData = null;
                      if (currentDayPlan && dayPlanLoaded) {
                        const now = new Date(currentTime);
                        
                        // Get ALL hours from the day plan (not just past hours)
                        const allHours = currentDayPlan.hourlySchedule;
                        
                        // Build complete traffic graph data from entire day plan
                        trafficGraphData = allHours.map(hourPlan => ({
                          hour: hourPlan.hour,
                          availableCount: hourPlan.availableCount,
                          occupiedCount: MACHINES.length - hourPlan.availableCount,
                          occupancyRate: parseFloat(hourPlan.occupancyRate),
                          timestamp: new Date(now.getFullYear(), now.getMonth(), now.getDate(), hourPlan.hour, 0, 0).toISOString()
                        }));
                      }
                      
                      const newStatsEntry = {
                        date: selectedDate.toISOString(),
                        periodKey: getPeriodKey(),
                        machines: machineStats, // Store per-machine accumulated readings
                        totalPlays: currentTotals.totalPlays,
                        medalsIn: currentTotals.medalsIn,
                        medalsOut: currentTotals.medalsOut,
                        bbCount: currentTotals.bbCount,
                        rbCount: currentTotals.rbCount,
                        payout: currentTotals.payout,
                        popularity: { ...machinePopularity },  // Current popularity (will be updated below)
                        activeHanabiVariant: activeHanabiVariant  // Track which Hanabi was active
                      };
                      
                      const updatedCalendarStats = {
                        ...calendarStats,
                        [dateKey]: newStatsEntry
                      };
                      
                      setCalendarStats(updatedCalendarStats);
                      
                      // Save traffic graph to daily traffic graphs if we have data
                      if (trafficGraphData && trafficGraphData.length > 0) {
                        const updatedGraphs = { 
                          ...dailyTrafficGraphs, 
                          [dateKey]: trafficGraphData 
                        };
                        setDailyTrafficGraphs(updatedGraphs);
                        
                        try {
                          await window.storage.set('parlour-daily-graphs', JSON.stringify(updatedGraphs));
                          console.log(`‚úÖ Traffic graph copied for ${dateKey}`);
                        } catch (error) {
                          console.error('Error saving traffic graph:', error);
                        }
                      }
                      
                      // Save daily stats for each machine
                      const newDailyStats = { ...dailyStats };
                      MACHINES.forEach(machine => {
                        // Save the accumulated counter reading for tomorrow's calculation
                        const machineKey = `${dateKey}-${machine.id}`;
                        newDailyStats[machineKey] = {
                          totalPlays: getStat(machine.id, 'totalPlays'),
                          medalsIn: getStat(machine.id, 'medalsIn'),
                          medalsOut: getStat(machine.id, 'medalsOut'),
                          bbCount: getStat(machine.id, 'bbCount'),
                          rbCount: getStat(machine.id, 'rbCount')
                        };
                        
                        // Also save today's calculated difference for weekly totals
                        const todayKey = `${dateKey}-${machine.id}-today`;
                        newDailyStats[todayKey] = {
                          totalPlays: getStat(machine.id, 'totalPlays'),
                          medalsIn: getStat(machine.id, 'medalsIn'),
                          medalsOut: getStat(machine.id, 'medalsOut'),
                          bbCount: getStat(machine.id, 'bbCount'),
                          rbCount: getStat(machine.id, 'rbCount')
                        };
                      });
                      setDailyStats(newDailyStats);
                      
                      // CRITICAL: Now recalculate popularity using the updated calendar stats
                      // Pass the updatedCalendarStats directly (state hasn't updated yet!)
                      const newPopularity = calculatePopularityFromDaily(updatedCalendarStats);
                      
                      const captureTimestamp = new Date().toISOString(); // Current timestamp with time
                      setMachinePopularity(newPopularity);
                      setPopularityLastUpdated(captureTimestamp);
                      
                      // Update the calendar entry with the NEW popularity and timestamp
                      updatedCalendarStats[dateKey].popularity = newPopularity;
                      updatedCalendarStats[dateKey].popularityUpdated = captureTimestamp;
                      setCalendarStats(updatedCalendarStats);
                      
                      // Save calendar stats with updated popularity
                      try {
                        await window.storage.set('parlour-calendar-stats', JSON.stringify(updatedCalendarStats));
                        await window.storage.set('parlour-popularity', JSON.stringify(newPopularity));
                      } catch (error) {
                        console.error('Error saving calendar stats:', error);
                      }
                      
                      // Check if it's Sunday (day 0), and if so, calculate weekly totals
                      const dayOfWeek = selectedDate.getDay();
                      if (dayOfWeek === 0) {
                        // Calculate the week start (Monday)
                        const weekEnd = new Date(selectedDate);
                        weekEnd.setHours(0, 0, 0, 0);
                        const weekStart = new Date(weekEnd);
                        weekStart.setDate(weekEnd.getDate() - 6); // Go back 6 days to Monday
                        
                        const weekKey = `${weekStart.getFullYear()}-${weekStart.getMonth()}-${weekStart.getDate()}`;
                        
                        const newWeeklyStats = { ...weeklyStats };
                        
                        MACHINES.forEach(machine => {
                          let weekTotal = {
                            totalPlays: 0,
                            medalsIn: 0,
                            medalsOut: 0,
                            bbCount: 0,
                            rbCount: 0
                          };
                          
                          // Sum up all 7 days of the week
                          for (let i = 0; i < 7; i++) {
                            const currentDay = new Date(weekStart);
                            currentDay.setDate(weekStart.getDate() + i);
                            const dayKey = `${currentDay.getFullYear()}-${currentDay.getMonth()}-${currentDay.getDate()}-${machine.id}`;
                            
                            if (newDailyStats[dayKey]) {
                              weekTotal.totalPlays += newDailyStats[dayKey].totalPlays || 0;
                              weekTotal.medalsIn += newDailyStats[dayKey].medalsIn || 0;
                              weekTotal.medalsOut += newDailyStats[dayKey].medalsOut || 0;
                              weekTotal.bbCount += newDailyStats[dayKey].bbCount || 0;
                              weekTotal.rbCount += newDailyStats[dayKey].rbCount || 0;
                            }
                          }
                          
                          newWeeklyStats[`${weekKey}-${machine.id}`] = weekTotal;
                        });
                        
                        setWeeklyStats(newWeeklyStats);
                        await window.storage.set('parlour-weekly-stats', JSON.stringify(newWeeklyStats));
                        alert(`Stats captured for ${selectedDate.toLocaleDateString()}!\n\nTotal Plays: ${formatNumber(currentTotals.totalPlays)}\nPayout: ${currentTotals.payout}%\n\n‚úì Weekly totals calculated (Monday-Sunday)\n‚úì Popularity updated from daily performance!`);
                      } else {
                        alert(`Stats captured for ${selectedDate.toLocaleDateString()}!\n\nTotal Plays: ${formatNumber(currentTotals.totalPlays)}\nPayout: ${currentTotals.payout}%\n\n‚úì Popularity updated from daily performance!`);
                      }
                      
                      // Save to storage immediately
                      try {
                        await window.storage.set('parlour-daily-stats', JSON.stringify(newDailyStats));
                      } catch (error) {
                        console.error('Error saving daily stats:', error);
                      }
                    }}
                    className="w-full bg-gradient-to-r from-emerald-600 to-green-600 hover:from-emerald-700 hover:to-green-700 text-white font-bold py-3 px-6 rounded-lg transition-all flex items-center justify-center gap-2"
                  >
                    <Save size={20} />
                    Capture Current Stats to This Date
                  </button>
                  <p className="text-xs text-slate-400 mt-2 text-center">
                    This will save your current period totals to {selectedDate.toLocaleDateString()}
                  </p>
                </div>
                
                {/* Monthly Export Button - Only show on last day of current month */}
                {(() => {
                  const now = new Date(currentTime);
                  const isCurrentMonth = selectedDate.getFullYear() === now.getFullYear() && 
                                        selectedDate.getMonth() === now.getMonth();
                  
                  if (!isCurrentMonth) return null;
                  
                  const lastDayOfMonth = new Date(selectedDate.getFullYear(), selectedDate.getMonth() + 1, 0).getDate();
                  const isLastDay = selectedDate.getDate() === lastDayOfMonth;
                  
                  if (!isLastDay) return null;
                  
                  const monthKey = `${selectedDate.getFullYear()}-${selectedDate.getMonth()}`;
                  const isHidden = monthlyExportHidden[monthKey];
                  
                  if (isHidden) return null;
                  
                  const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 
                                    'July', 'August', 'September', 'October', 'November', 'December'];
                  
                  return (
                    <div className="mb-4">
                      <button
                        onClick={async () => {
                          try {
                            const year = selectedDate.getFullYear();
                            const month = selectedDate.getMonth();
                            const monthName = monthNames[month];
                            
                            // Gather all days in this month that have stats
                            const daysInMonth = new Date(year, month + 1, 0).getDate();
                            const monthStats = [];
                            let monthTotals = { totalPlays: 0, medalsIn: 0, medalsOut: 0, bbCount: 0, rbCount: 0 };
                            
                            for (let day = 1; day <= daysInMonth; day++) {
                              const dateKey = `${year}-${month}-${day}`;
                              const dayStats = calendarStats[dateKey];
                              if (dayStats) {
                                monthStats.push({ day, stats: dayStats });
                                monthTotals.totalPlays += dayStats.totalPlays || 0;
                                monthTotals.medalsIn += dayStats.medalsIn || 0;
                                monthTotals.medalsOut += dayStats.medalsOut || 0;
                                monthTotals.bbCount += dayStats.bbCount || 0;
                                monthTotals.rbCount += dayStats.rbCount || 0;
                              }
                            }
                            
                            const monthPayout = monthTotals.medalsIn > 0 
                              ? ((monthTotals.medalsOut / monthTotals.medalsIn) * 100).toFixed(1)
                              : 0;
                            
                            // Calculate per-machine monthly totals from existing daily stats
                            const machineMonthlySummary = {};
                            MACHINES.forEach(machine => {
                              machineMonthlySummary[machine.id] = {
                                name: machine.name,
                                totalPlays: 0,
                                medalsIn: 0,
                                medalsOut: 0,
                                bbCount: 0,
                                rbCount: 0
                              };
                            });
                            
                            monthStats.forEach(({ stats }) => {
                              if (stats.machines) {
                                Object.entries(stats.machines).forEach(([machineId, machineData]) => {
                                  if (machineMonthlySummary[machineId]) {
                                    machineMonthlySummary[machineId].totalPlays += machineData.totalPlays || 0;
                                    machineMonthlySummary[machineId].medalsIn += machineData.medalsIn || 0;
                                    machineMonthlySummary[machineId].medalsOut += machineData.medalsOut || 0;
                                    machineMonthlySummary[machineId].bbCount += machineData.bbCount || 0;
                                    machineMonthlySummary[machineId].rbCount += machineData.rbCount || 0;
                                  }
                                });
                              }
                            });
                            
                            // Find top 3 machines by total plays
                            const topMachines = Object.values(machineMonthlySummary)
                              .filter(m => m.totalPlays > 0)
                              .sort((a, b) => b.totalPlays - a.totalPlays)
                              .slice(0, 3);
                            
                            // Find most popular day (highest total plays)
                            const mostPopularDay = monthStats.reduce((max, current) => {
                              return (current.stats.totalPlays > max.stats.totalPlays) ? current : max;
                            }, monthStats[0]);
                            
                            // Build export text
                            const lines = [];
                            lines.push('‚ïê'.repeat(80));
                            lines.push(`${hallName.toUpperCase()} - MONTHLY REPORT`);
                            lines.push('‚ïê'.repeat(80));
                            lines.push('');
                            lines.push(`Month: ${monthName} ${year}`);
                            lines.push(`Generated: ${new Date().toLocaleString()}`);
                            lines.push('');
                            
                            lines.push('‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê');
                            lines.push('‚îÇ MONTHLY TOTALS                                                              ‚îÇ');
                            lines.push('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò');
                            lines.push('');
                            lines.push(`Total Plays: ${formatNumber(monthTotals.totalPlays)}`);
                            lines.push(`Medals In: ${formatNumber(monthTotals.medalsIn)}`);
                            lines.push(`Medals Out: ${formatNumber(monthTotals.medalsOut)}`);
                            lines.push(`Payout Rate: ${monthPayout}%`);
                            lines.push(`Big Bonus: ${formatNumber(monthTotals.bbCount)} hits`);
                            lines.push(`Regular Bonus: ${formatNumber(monthTotals.rbCount)} hits`);
                            lines.push(`Days with Data: ${monthStats.length} / ${daysInMonth} days`);
                            lines.push('');
                            
                            if (topMachines.length > 0) {
                              lines.push('‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê');
                              lines.push('‚îÇ TOP 3 MACHINES (BY TOTAL PLAYS)                                            ‚îÇ');
                              lines.push('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò');
                              lines.push('');
                              
                              topMachines.forEach((machine, idx) => {
                                const machinePayout = machine.medalsIn > 0 
                                  ? ((machine.medalsOut / machine.medalsIn) * 100).toFixed(1)
                                  : 0;
                                lines.push(`${idx + 1}. ${machine.name}`);
                                lines.push(`   Plays: ${formatNumber(machine.totalPlays)} | In: ${formatNumber(machine.medalsIn)} | Out: ${formatNumber(machine.medalsOut)}`);
                                lines.push(`   Payout: ${machinePayout}% | BB: ${formatNumber(machine.bbCount)} | RB: ${formatNumber(machine.rbCount)}`);
                                lines.push('');
                              });
                            }
                            
                            if (mostPopularDay) {
                              lines.push('‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê');
                              lines.push('‚îÇ MOST POPULAR DAY                                                            ‚îÇ');
                              lines.push('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò');
                              lines.push('');
                              const popularDate = new Date(year, month, mostPopularDay.day);
                              const dayName = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'][popularDate.getDay()];
                              lines.push(`${monthName} ${mostPopularDay.day} (${dayName})`);
                              lines.push(`Total Plays: ${formatNumber(mostPopularDay.stats.totalPlays)}`);
                              lines.push(`Medals In: ${formatNumber(mostPopularDay.stats.medalsIn)}`);
                              lines.push(`Medals Out: ${formatNumber(mostPopularDay.stats.medalsOut)}`);
                              lines.push(`Payout: ${mostPopularDay.stats.payout}%`);
                              lines.push('');
                            }
                            
                            if (monthStats.length > 0) {
                              lines.push('‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê');
                              lines.push('‚îÇ DAILY BREAKDOWN                                                             ‚îÇ');
                              lines.push('‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò');
                              lines.push('');
                              
                              monthStats.forEach(({ day, stats }) => {
                                const date = new Date(year, month, day);
                                const dayName = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'][date.getDay()];
                                lines.push(`${monthName} ${day} (${dayName}):`);
                                lines.push(`  Plays: ${formatNumber(stats.totalPlays)} | In: ${formatNumber(stats.medalsIn)} | Out: ${formatNumber(stats.medalsOut)} | Payout: ${stats.payout}%`);
                                lines.push(`  BB: ${formatNumber(stats.bbCount)} | RB: ${formatNumber(stats.rbCount)}`);
                                lines.push('');
                              });
                            }
                            
                            lines.push('‚ïê'.repeat(80));
                            lines.push('END OF MONTHLY REPORT');
                            lines.push('‚ïê'.repeat(80));
                            
                            const exportText = lines.join('\n');
                            const blob = new Blob([exportText], { type: 'text/plain' });
                            const url = URL.createObjectURL(blob);
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = `${hallName.replace(/\s+/g, '-')}-${monthName}-${year}.txt`;
                            document.body.appendChild(a);
                            a.click();
                            document.body.removeChild(a);
                            URL.revokeObjectURL(url);
                            
                            // Hide button for this month
                            const newHidden = { ...monthlyExportHidden, [monthKey]: true };
                            setMonthlyExportHidden(newHidden);
                            await window.storage.set('parlour-monthly-export-hidden', JSON.stringify(newHidden));
                            
                            alert(`Monthly report for ${monthName} ${year} exported successfully!`);
                          } catch (error) {
                            alert('Error exporting monthly report: ' + error.message);
                          }
                        }}
                        className="w-full bg-gradient-to-r from-blue-600 to-indigo-600 hover:from-blue-700 hover:to-indigo-700 text-white font-bold py-3 px-6 rounded-lg transition-all flex items-center justify-center gap-2"
                      >
                        <Download size={20} />
                        Export {monthNames[selectedDate.getMonth()]} Monthly Report
                      </button>
                      <p className="text-xs text-slate-400 mt-2 text-center">
                        Download a complete report for this month (available once per month)
                      </p>
                    </div>
                  );
                })()}
                
                {/* Stats Summary */}
                <div className="mb-4">
                  <label className="block text-sm font-medium mb-2 text-slate-300">Stats Summary</label>
                  <div className="bg-gradient-to-br from-slate-800 to-slate-900 border-2 border-purple-500/30 rounded-lg p-6">
                    {(() => {
                      try {
                        const dateKey = `${selectedDate.getFullYear()}-${selectedDate.getMonth()}-${selectedDate.getDate()}`;
                        const savedStats = calendarStats[dateKey];
                        
                        if (savedStats) {
                          return (
                            <div className="space-y-4">
                              <div className="flex items-center gap-2 mb-4">
                                <div className="text-emerald-400 font-bold">‚úì Stats Captured</div>
                                <div className="text-xs text-slate-400">
                                  ({savedStats.periodKey || 'N/A'})
                                </div>
                              </div>
                              
                              <div className="grid grid-cols-2 gap-4">
                                <div className="bg-slate-700/50 rounded-lg p-3">
                                  <div className="text-xs text-purple-300 font-medium mb-1">Total Plays</div>
                                  <div className="text-2xl font-bold text-white">{formatNumber(savedStats.totalPlays || 0)}</div>
                                </div>
                                
                                <div className="bg-slate-700/50 rounded-lg p-3">
                                  <div className="text-xs text-purple-300 font-medium mb-1">Payout %</div>
                                  <div className="text-2xl font-bold text-white">{savedStats.payout || 0}%</div>
                                </div>
                                
                                <div className="bg-slate-700/50 rounded-lg p-3">
                                  <div className="text-xs text-red-300 font-medium mb-1">Medals In</div>
                                  <div className="text-xl font-bold text-white">{formatNumber(savedStats.medalsIn || 0)}</div>
                                </div>
                                
                                <div className="bg-slate-700/50 rounded-lg p-3">
                                  <div className="text-xs text-green-300 font-medium mb-1">Medals Out</div>
                                  <div className="text-xl font-bold text-white">{formatNumber(savedStats.medalsOut || 0)}</div>
                                </div>
                                
                                <div className="bg-slate-700/50 rounded-lg p-3">
                                  <div className="text-xs text-yellow-300 font-medium mb-1">BB Count</div>
                                  <div className="text-xl font-bold text-white">{formatNumber(savedStats.bbCount || 0)}</div>
                                </div>
                                
                                <div className="bg-slate-700/50 rounded-lg p-3">
                                  <div className="text-xs text-blue-300 font-medium mb-1">RB Count</div>
                                  <div className="text-xl font-bold text-white">{formatNumber(savedStats.rbCount || 0)}</div>
                                </div>
                              </div>
                              
                              {/* Individual Machine Stats */}
                              {savedStats.machines && Object.keys(savedStats.machines).length > 0 && (
                                <div className="mt-6 pt-6 border-t border-slate-600">
                                  <h5 className="text-sm font-bold text-emerald-300 mb-4">Individual Machine Stats (Captured)</h5>
                                  <div className="space-y-3 max-h-96 overflow-y-auto">
                                    {(() => {
                                      // Determine which machines to display based on what was active at the time
                                      const savedHanabiVariant = savedStats.activeHanabiVariant || 'hanabi';
                                      const machinesToShow = registry.getActive().filter(m => {
                                        // Show both non-Hanabi machines and the Hanabi variant that was active
                                        if (m.id === 'hanabi' || m.id === 'hanabiMatte') {
                                          return m.id === savedHanabiVariant;
                                        }
                                        return true;
                                      });
                                      
                                      return machinesToShow.map(machine => {
                                        const machineStats = savedStats.machines[machine.id];
                                        if (!machineStats) return null;
                                        
                                        const machinePayout = machineStats.medalsIn > 0 
                                          ? ((machineStats.medalsOut / machineStats.medalsIn) * 100).toFixed(1)
                                          : 0;
                                        
                                        return (
                                          <div key={machine.id} className="bg-slate-800/50 rounded-lg p-4">
                                            <div className="flex justify-between items-center mb-3">
                                              <h6 className="text-base font-bold text-white">{machine.name}</h6>
                                              <span className="text-xs bg-purple-600/40 text-purple-200 px-2 py-1 rounded">
                                                Setting: {machineStats.setting || 'N/A'}
                                              </span>
                                            </div>
                                            <div className="grid grid-cols-3 gap-3">
                                              <div>
                                                <div className="text-xs text-slate-400">Total Plays</div>
                                                <div className="text-sm font-bold text-white">{formatNumber(machineStats.totalPlays || 0)}</div>
                                              </div>
                                              <div>
                                                <div className="text-xs text-slate-400">Medals In</div>
                                                <div className="text-sm font-bold text-white">{formatNumber(machineStats.medalsIn || 0)}</div>
                                              </div>
                                              <div>
                                                <div className="text-xs text-slate-400">Medals Out</div>
                                                <div className="text-sm font-bold text-white">{formatNumber(machineStats.medalsOut || 0)}</div>
                                              </div>
                                              <div>
                                                <div className="text-xs text-slate-400">Payout %</div>
                                                <div className="text-sm font-bold text-white">{machinePayout}%</div>
                                              </div>
                                              <div>
                                                <div className="text-xs text-slate-400">BB Count</div>
                                                <div className="text-sm font-bold text-white">{formatNumber(machineStats.bbCount || 0)}</div>
                                              </div>
                                              <div>
                                                <div className="text-xs text-slate-400">RB Count</div>
                                                <div className="text-sm font-bold text-white">{formatNumber(machineStats.rbCount || 0)}</div>
                                              </div>
                                            </div>
                                          </div>
                                        );
                                      });
                                    })()}
                                  </div>
                                </div>
                              )}
                              
                              {savedStats.popularity && (
                                <div className="mt-6 pt-6 border-t border-slate-600">
                                  <h5 className="text-sm font-bold text-indigo-300 mb-4">Machine Popularity Rankings (Captured)</h5>
                                  <div className="space-y-2">
                                    {(() => {
                                      // Determine which Hanabi variant was active when this was captured
                                      const savedHanabiVariant = savedStats.activeHanabiVariant || 'hanabi';
                                      const machinesToShow = registry.getActive().filter(m => {
                                        if (m.id === 'hanabi' || m.id === 'hanabiMatte') {
                                          return m.id === savedHanabiVariant;
                                        }
                                        return true;
                                      });
                                      
                                      const sortedMachines = [...machinesToShow].sort((a, b) => {
                                        const popA = savedStats.popularity[a.id] || 0;
                                        const popB = savedStats.popularity[b.id] || 0;
                                        
                                        // Normalize to 0-1 range if needed
                                        const normalizedA = popA > 1 ? popA / 100 : popA;
                                        const normalizedB = popB > 1 ? popB / 100 : popB;
                                        
                                        return normalizedB - normalizedA;
                                      });
                                      
                                      const allPopularities = machinesToShow.map(m => {
                                        const pop = savedStats.popularity[m.id] || 0;
                                        return pop > 1 ? pop / 100 : pop;
                                      });
                                      const maxPopularity = Math.max(...allPopularities);
                                      
                                      return sortedMachines.map((machine, index) => {
                                        const rawPop = savedStats.popularity[machine.id] || 0;
                                        
                                        // Normalize: if > 1, it's stored as percentage (old format), convert to 0-1
                                        const popularity = rawPop > 1 ? rawPop / 100 : rawPop;
                                        const percentage = Math.round(popularity * 100);
                                        const barWidth = maxPopularity > 0 ? (popularity / maxPopularity) * 100 : 0;
                                        
                                        return (
                                          <div key={machine.id} className="bg-slate-800/50 rounded p-3">
                                            <div className="flex items-center justify-between mb-1">
                                              <div className="flex items-center gap-2">
                                                <span className="text-sm font-bold text-indigo-400">#{index + 1}</span>
                                                <span className="text-sm font-semibold text-white">{machine.name}</span>
                                              </div>
                                              <span className="text-sm font-bold text-indigo-300">{percentage}%</span>
                                            </div>
                                            <div className="w-full bg-slate-700/50 rounded-full h-4 overflow-hidden">
                                              <div 
                                                className="h-full bg-gradient-to-r from-indigo-500 to-purple-500 rounded-full transition-all duration-500"
                                                style={{ width: `${barWidth}%` }}
                                              />
                                            </div>
                                          </div>
                                        );
                                      });
                                    })()}
                                  </div>
                                </div>
                              )}
                              
                              <div className="text-xs text-slate-500 mt-3 italic text-center">
                                üíæ Saved on {new Date(savedStats.date).toLocaleString()}
                              </div>
                            </div>
                          );
                        } else {
                          return (
                            <div className="text-center py-8">
                              <div className="text-slate-400 text-lg mb-2">üìä No Stats Recorded</div>
                              <div className="text-slate-500 text-sm">
                                Press "Capture Current Stats" above to save stats for this day
                              </div>
                            </div>
                          );
                        }
                      } catch (error) {
                        console.error('Error rendering stats:', error);
                        return (
                          <div className="text-center py-8">
                            <div className="text-red-400 text-lg mb-2">‚ö†Ô∏è Error Loading Stats</div>
                            <div className="text-slate-500 text-sm">
                              {error.message}
                            </div>
                          </div>
                        );
                      }
                    })()}
                  </div>
                </div>
                
                {/* Traffic Graph for Selected Day */}
                <div className="mb-4">
                  <label className="block text-sm font-medium mb-2 text-slate-300">Hall Traffic & Occupancy</label>
                  <div className="bg-gradient-to-br from-slate-800 to-slate-900 border-2 border-purple-500/30 rounded-lg p-6">
                    {(() => {
                      try {
                        const dateKey = `${selectedDate.getFullYear()}-${selectedDate.getMonth()}-${selectedDate.getDate()}`;
                        const savedGraph = dailyTrafficGraphs[dateKey];
                        
                        if (savedGraph && savedGraph.length > 0) {
                          return (
                            <>
                              <div className="flex items-center gap-2 mb-4">
                                <div className="text-emerald-400 font-bold">‚úì Traffic Data Saved</div>
                                <div className="text-xs text-slate-400">
                                  ({savedGraph.length} data points)
                                </div>
                              </div>
                              <ResponsiveContainer width="100%" height={300}>
                                <LineChart data={savedGraph}>
                                  <CartesianGrid strokeDasharray="3 3" stroke="#374151" />
                                  <XAxis 
                                    dataKey="hour" 
                                    stroke="#9ca3af"
                                    label={{ value: 'Hour of Day', position: 'insideBottom', offset: -5, fill: '#9ca3af' }}
                                    domain={[
                                      selectedDate.getDay() === 0 || selectedDate.getDay() === 6 ? 7 : 8,
                                      23
                                    ]}
                                    type="number"
                                    tickFormatter={(hour) => `${hour}:00`}
                                  />
                                  <YAxis stroke="#9ca3af" />
                                  <Tooltip 
                                    contentStyle={{ backgroundColor: '#1e293b', border: '1px solid #4b5563' }}
                                    labelFormatter={(hour) => `${hour}:00`}
                                    formatter={(value, name) => {
                                      if (name === 'Occupancy Rate') return `${value}%`;
                                      return value;
                                    }}
                                  />
                                  <Legend />
                                  <Line type="monotone" dataKey="availableCount" stroke="#10b981" name="Available Machines" strokeWidth={2} />
                                  <Line type="monotone" dataKey="occupiedCount" stroke="#ef4444" name="Occupied Machines" strokeWidth={2} />
                                  <Line type="monotone" dataKey="occupancyRate" stroke="#a855f7" name="Occupancy Rate (%)" strokeWidth={3} />
                                </LineChart>
                              </ResponsiveContainer>
                              <p className="text-xs text-slate-400 mt-3">
                                üìä Hall traffic for {selectedDate.toLocaleDateString()} ({selectedDate.getDay() === 0 || selectedDate.getDay() === 6 ? '7 AM - 11 PM' : '8 AM - 11 PM'})
                              </p>
                            </>
                          );
                        } else {
                          return (
                            <div className="text-center py-8">
                              <div className="text-slate-400 text-lg mb-2">üìä No Traffic Data</div>
                              <div className="text-slate-500 text-sm">
                                Traffic graph will be automatically saved when the hall closes on this day
                              </div>
                            </div>
                          );
                        }
                      } catch (error) {
                        console.error('Error rendering traffic graph:', error);
                        return (
                          <div className="text-center py-8">
                            <div className="text-red-400 text-lg mb-2">‚ö†Ô∏è Error Loading Graph</div>
                            <div className="text-slate-500 text-sm">
                              {error.message}
                            </div>
                          </div>
                        );
                      }
                    })()}
                  </div>
                </div>
                
                {/* Notes (Editable) */}
                <div>
                  <label className="block text-sm font-medium mb-2 text-slate-300">Your Notes</label>
                  <textarea
                    value={(() => {
                      try {
                        const noteKey = `${selectedDate.getFullYear()}-${selectedDate.getMonth()}-${selectedDate.getDate()}`;
                        return calendarNotes[noteKey] || '';
                      } catch (error) {
                        console.error('Error loading notes:', error);
                        return '';
                      }
                    })()}
                    onChange={(e) => {
                      try {
                        const noteKey = `${selectedDate.getFullYear()}-${selectedDate.getMonth()}-${selectedDate.getDate()}`;
                        setCalendarNotes(prev => ({
                          ...prev,
                          [noteKey]: e.target.value
                        }));
                      } catch (error) {
                        console.error('Error saving notes:', error);
                      }
                    }}
                    className="w-full bg-slate-700 border border-slate-600 rounded-lg px-4 py-3 text-white min-h-[150px] resize-y"
                    placeholder="Enter your notes for this day...

Examples:
- Customer observations
- Machine performance notes
- Weather conditions
- Special events
- Staff notes"
                  />
                </div>
              </div>
            )}

            <div className={`${isNightMode ? 'bg-slate-900/70' : 'bg-slate-800/50'} backdrop-blur rounded-lg p-6 border border-purple-500/20 transition-colors duration-1000`}>
              <h4 className="text-xl font-bold mb-4 text-purple-300">
                Holidays & Promotions in {['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'][calendarMonth]} {calendarYear}
              </h4>
              
              {(() => {
                const monthHolidays = japaneseHolidays.filter(h => {
                  const holidayDate = new Date(h.start);
                  return holidayDate.getMonth() === calendarMonth && holidayDate.getFullYear() === calendarYear;
                });

                const monthPromos = customPromotions.filter(p => {
                  const promoDate = new Date(p.date);
                  return promoDate.getMonth() === calendarMonth && promoDate.getFullYear() === calendarYear;
                });

                if (monthHolidays.length === 0 && monthPromos.length === 0) {
                  return <p className="text-slate-400 italic">No holidays or promotions this month</p>;
                }

                return (
                  <div className="space-y-4">
                    {monthHolidays.length > 0 && (
                      <div>
                        <h5 className="text-sm font-bold text-yellow-300 mb-3">üéå Public Holidays</h5>
                        <div className="space-y-3">
                          {monthHolidays.map((holiday, idx) => {
                            const isPeakPeriod = holiday.name.includes('Golden Week') || holiday.name.includes('Silver Week');
                            return (
                              <div
                                key={idx}
                                className={`p-4 rounded-lg border ${
                                  isPeakPeriod
                                    ? 'bg-red-900/30 border-red-500/50'
                                    : 'bg-yellow-900/30 border-yellow-500/50'
                                }`}
                              >
                                <div className="flex justify-between items-start">
                                  <div>
                                    <div className={`font-bold ${
                                      isPeakPeriod ? 'text-red-300' : 'text-yellow-300'
                                    }`}>
                                      {isPeakPeriod && 'üî• '}
                                      {holiday.name}
                                    </div>
                                    <div className="text-sm text-slate-400 mt-1">
                                      {new Date(holiday.start).toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric', year: 'numeric' })}
                                    </div>
                                  </div>
                                  {isPeakPeriod && (
                                    <span className="text-xs bg-red-600/40 text-red-200 px-2 py-1 rounded border border-red-500/60 font-bold">
                                      PEAK TRAFFIC
                                    </span>
                                  )}
                                </div>
                              </div>
                            );
                          })}
                        </div>
                      </div>
                    )}

                    {monthPromos.length > 0 && (
                      <div>
                        <h5 className="text-sm font-bold text-pink-300 mb-3">üéØ Custom Promotions</h5>
                        <div className="space-y-3">
                          {monthPromos.map((promo, idx) => {
                            const promoDate = new Date(promo.date);
                            return (
                              <div
                                key={idx}
                                className="p-4 rounded-lg border bg-pink-900/30 border-pink-500/50"
                              >
                                <div className="font-bold text-pink-300">{promo.name}</div>
                                <div className="text-sm text-slate-400 mt-1">
                                  {promoDate.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric', year: 'numeric' })}
                                </div>
                                {promo.details && (
                                  <div className="text-sm text-pink-200 mt-2">
                                    {promo.details}
                                  </div>
                                )}
                                {promo.rules && (
                                  <div className="text-xs text-slate-400 mt-2 italic">
                                    Rules: {promo.rules}
                                  </div>
                                )}
                              </div>
                            );
                          })}
                        </div>
                      </div>
                    )}
                  </div>
                );
              })()}
            </div>
          </div>
        )}

        {activeTab === 'notes' && (
          <div className={`${isNightMode ? 'bg-slate-900/70' : 'bg-slate-800/50'} rounded-lg p-6 border border-purple-500/20 transition-colors duration-1000`}>
            <h3 className="text-xl font-bold mb-4 text-purple-300">General Notes</h3>
            <textarea
              value={generalNotes[getPeriodKey()] || ''}
              onChange={(e) => setGeneralNotes(prev => ({...prev, [getPeriodKey()]: e.target.value}))}
              className="w-full bg-slate-700 border border-slate-600 rounded-lg px-4 py-3 text-white min-h-[400px]"
              placeholder="Enter notes..."
            />
          </div>
        )}

        {activeTab === 'procedures' && (
          <div className={`${isNightMode ? 'bg-slate-900/70' : 'bg-slate-800/50'} rounded-lg p-6 border border-purple-500/20 transition-colors duration-1000`}>
            <h3 className="text-xl font-bold mb-4 text-purple-300">Parlour Procedures</h3>
            <textarea
              value={procedures}
              onChange={(e) => setProcedures(e.target.value)}
              className="w-full bg-slate-700 border border-slate-600 rounded-lg px-4 py-3 text-white min-h-[400px]"
              placeholder="Enter procedures..."
            />
          </div>
        )}

        {activeTab === 'about' && (
          <div className={`${isNightMode ? 'bg-slate-900/70' : 'bg-slate-800/50'} rounded-lg p-6 border border-purple-500/20 transition-colors duration-1000`}>
            <h3 className="text-xl font-bold mb-4 text-purple-300">About Project A Hall Tracker</h3>
          </div>
        )}

        <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mt-6">
          <button onClick={saveData} className="bg-green-600 hover:bg-green-700 text-white font-bold py-3 rounded-lg flex items-center justify-center gap-2">
            <Save size={20} />
            Save Data
          </button>
          <button onClick={exportData} className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 rounded-lg flex items-center justify-center gap-2">
            <Download size={20} />
            Export TXT
          </button>
          <button onClick={backupData} className="bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 rounded-lg flex items-center justify-center gap-2">
            <Database size={20} />
            Backup JSON
          </button>
          <label className="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-3 rounded-lg flex items-center justify-center gap-2 cursor-pointer">
            <Upload size={20} />
            Load Backup
            <input
              key={fileInputKey}
              type="file"
              accept=".json"
              onChange={loadBackup}
              className="hidden"
            />
          </label>
        </div>



        <div className={`mt-4 ${isNightMode ? 'bg-slate-900/70' : 'bg-slate-800/50'} backdrop-blur rounded-lg p-4 border border-slate-600`}>
          <h4 className="text-sm font-bold text-slate-300 mb-3">üìä Storage Statistics</h4>
          <div className="grid grid-cols-2 md:grid-cols-4 gap-3 text-xs">
            <div>
              <div className="text-slate-500">Calendar Stats</div>
              <div className="text-white font-bold">{Object.keys(calendarStats).length} days</div>
            </div>
            <div>
              <div className="text-slate-500">Traffic Graphs</div>
              <div className="text-white font-bold">{Object.keys(dailyTrafficGraphs).length} days</div>
            </div>
            <div>
              <div className="text-slate-500">Day Plans</div>
              <div className="text-white font-bold">{Object.keys(preDeterminedDays).length} days</div>
            </div>
            <div>
              <div className="text-slate-500">Traffic History</div>
              <div className="text-white font-bold">{trafficHistory.length} entries</div>
            </div>
          </div>
        </div>

        <div className="mt-4">
          <button 
            onClick={() => setShowResetConfirm(true)}
            className="w-full bg-gradient-to-r from-red-600 to-orange-600 hover:from-red-700 hover:to-orange-700 text-white font-bold py-3 rounded-lg flex items-center justify-center gap-2"
          >
            ‚ö†Ô∏è Reset All Data
          </button>
        </div>

        {/* Restore Options Modal */}
        {showRestoreOptions && (
          <div 
            className="fixed inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center z-50 p-4" 
            onClick={(e) => {
              if (e.target === e.currentTarget) {
                setShowRestoreOptions(false);
                window.pendingBackup = null;
              }
            }}
          >
            <div className={`${isNightMode ? 'bg-slate-900' : 'bg-slate-800'} rounded-lg p-6 max-w-2xl w-full max-h-[90vh] overflow-hidden border-2 border-purple-500/40 flex flex-col`}>
              <h3 className="text-2xl font-bold mb-2 text-purple-300">Select Data to Restore</h3>
              <p className="text-slate-300 mb-4">Choose which portions of the backup to restore. Unchecked items will keep their current values.</p>
              
              <div className="overflow-y-auto flex-1 pr-2" style={{ maxHeight: 'calc(90vh - 200px)' }}>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-6">
                  {[
                    { key: 'stats', label: 'Machine Stats', desc: 'Play counts, medals, bonuses' },
                    { key: 'settings', label: 'Machine Settings', desc: 'Current odds settings' },
                    { key: 'adjustments', label: 'Adjustments', desc: 'Graph patterns, notes' },
                    { key: 'designatedLosers', label: 'Designated Losers', desc: 'Per-period loser data' },
                    { key: 'cycles', label: 'Cycles & Weeks', desc: 'Current period tracking' },
                    { key: 'userMachines', label: 'Hall Machines', desc: 'Machines on the floor' },
                    { key: 'machinePopularity', label: 'Machine Popularity', desc: 'Popularity ratings (0.0-1.0)' },
                    { key: 'generalNotes', label: 'General Notes', desc: 'Period notes' },
                    { key: 'retiredMachines', label: 'Retired Machines', desc: 'Retirement status' },
                    { key: 'procedures', label: 'Procedures', desc: 'Parlour procedures' },
                    { key: 'calendarNotes', label: 'Calendar Notes', desc: 'Daily notes' },
                    { key: 'customPromotions', label: 'Custom Promotions', desc: 'Promotion events' },
                    { key: 'calendarStats', label: 'Calendar Stats', desc: 'Daily snapshots with machine data & popularity' },
                    { key: 'dailyTrafficGraphs', label: 'Daily Traffic Graphs', desc: 'Saved daily traffic patterns' },
                    { key: 'allTimeStats', label: 'All-Time Stats', desc: 'Cumulative lifetime data' },
                    { key: 'preDeterminedDays', label: 'Pre-Determined Day Plans', desc: 'Locked daily patterns' },
                    { key: 'currentDayPlan', label: 'Current Day Plan', desc: 'Active day pattern' },
                    { key: 'dayPlanLoaded', label: 'Day Plan Status', desc: 'Plan load state' },
                    { key: 'activeHanabiVariant', label: 'Hanabi System', desc: 'Active variant & swap data' },
                    { key: 'hallName', label: 'Hall Name', desc: 'Custom hall name' },
                    { key: 'monthlyExportHidden', label: 'Monthly Export Status', desc: 'Export completion tracking' }
                  ].map(({ key, label, desc }) => (
                    <label key={key} className="flex items-start gap-3 p-3 bg-slate-700/50 rounded-lg cursor-pointer hover:bg-slate-700 transition-colors">
                      <input
                        type="checkbox"
                        checked={restoreOptions[key]}
                        onChange={(e) => setRestoreOptions(prev => ({ ...prev, [key]: e.target.checked }))}
                        className="w-5 h-5 mt-0.5 flex-shrink-0"
                      />
                      <div className="flex-1 min-w-0">
                        <div className="text-sm font-medium text-white">{label}</div>
                        <div className="text-xs text-slate-400">{desc}</div>
                      </div>
                    </label>
                  ))}
                </div>
              </div>

              <div className="flex gap-3 mt-4 pt-4 border-t border-slate-700">
                <button
                  onClick={() => {
                    const allChecked = Object.values(restoreOptions).every(v => v);
                    const newState = {};
                    Object.keys(restoreOptions).forEach(key => {
                      newState[key] = !allChecked;
                    });
                    setRestoreOptions(newState);
                  }}
                  className="bg-slate-600 hover:bg-slate-700 text-white font-medium py-2 px-4 rounded-lg"
                >
                  Toggle All
                </button>
                <button
                  onClick={confirmRestore}
                  className="flex-1 bg-gradient-to-r from-green-600 to-emerald-600 hover:from-green-700 hover:to-emerald-700 text-white font-bold py-3 rounded-lg"
                >
                  ‚úì Restore Selected Data
                </button>
                <button
                  onClick={() => {
                    setShowRestoreOptions(false);
                    window.pendingBackup = null;
                  }}
                  className="bg-red-600 hover:bg-red-700 text-white font-bold py-3 px-6 rounded-lg"
                >
                  Cancel
                </button>
              </div>
            </div>
          </div>
        )}

        {/* Reset Confirmation Modal */}
        {showResetConfirm && (
          <div 
            className="fixed inset-0 bg-black/80 backdrop-blur-sm flex items-center justify-center z-50 p-4"
            onClick={(e) => {
              if (e.target === e.currentTarget) {
                setShowResetConfirm(false);
              }
            }}
          >
            <div className={`${isNightMode ? 'bg-slate-900' : 'bg-slate-800'} rounded-lg p-8 max-w-lg w-full border-2 border-red-500/60 shadow-2xl`}>
              <div className="text-center mb-6">
                <div className="text-6xl mb-4">‚ö†Ô∏è</div>
                <h3 className="text-3xl font-bold mb-3 text-red-300">Reset All Data?</h3>
                <p className="text-slate-300 text-lg mb-4">
                  This will permanently delete ALL of the following data:
                </p>
              </div>

              <div className="bg-red-900/30 border border-red-500/50 rounded-lg p-4 mb-6">
                <ul className="space-y-2 text-sm text-red-200">
                  <li className="flex items-center gap-2">
                    <span className="text-red-400">‚Ä¢</span>
                    <span>All Machine Stats (plays, medals, bonuses)</span>
                  </li>
                  <li className="flex items-center gap-2">
                    <span className="text-red-400">‚Ä¢</span>
                    <span>Machine Settings</span>
                  </li>
                  <li className="flex items-center gap-2">
                    <span className="text-red-400">‚Ä¢</span>
                    <span>Adjustments & Observations</span>
                  </li>
                  <li className="flex items-center gap-2">
                    <span className="text-red-400">‚Ä¢</span>
                    <span>Designated Losers</span>
                  </li>
                  <li className="flex items-center gap-2">
                    <span className="text-red-400">‚Ä¢</span>
                    <span>Retired Machines</span>
                  </li>
                  <li className="flex items-center gap-2">
                    <span className="text-red-400">‚Ä¢</span>
                    <span>Calendar Notes & Stats</span>
                  </li>
                  <li className="flex items-center gap-2">
                    <span className="text-red-400">‚Ä¢</span>
                    <span>Custom Promotions</span>
                  </li>
                  <li className="flex items-center gap-2">
                    <span className="text-red-400">‚Ä¢</span>
                    <span>Traffic Graphs & History</span>
                  </li>
                  <li className="flex items-center gap-2">
                    <span className="text-red-400">‚Ä¢</span>
                    <span>Machine Popularity (reset to 50%)</span>
                  </li>
                </ul>
              </div>

              <div className="bg-yellow-900/30 border border-yellow-500/50 rounded-lg p-4 mb-6">
                <p className="text-yellow-200 text-sm font-bold mb-2">‚ö†Ô∏è WARNING:</p>
                <p className="text-yellow-100 text-sm">
                  This action CANNOT be undone! Make sure you have created a backup (Backup JSON button) before proceeding.
                </p>
              </div>

              <div className="flex gap-3">
                <button
                  onClick={() => setShowResetConfirm(false)}
                  className="flex-1 bg-slate-600 hover:bg-slate-700 text-white font-bold py-4 rounded-lg text-lg"
                >
                  Cancel
                </button>
                <button
                  onClick={resetAllData}
                  className="flex-1 bg-gradient-to-r from-red-600 to-orange-600 hover:from-red-700 hover:to-orange-700 text-white font-bold py-4 rounded-lg text-lg"
                >
                  Yes, Reset Everything
                </button>
              </div>
            </div>
          </div>
        )}
      </div>


    </div>
  );
}

export default App;
    function App() {
      return (
        <div className="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 text-white p-4">
          <div className="max-w-4xl mx-auto mt-20">
            <div className="bg-slate-800/50 backdrop-blur rounded-lg p-8 border border-purple-500/20">
              <h1 className="text-4xl font-bold bg-gradient-to-r from-purple-400 to-pink-400 bg-clip-text text-transparent mb-6">
                üé∞ Project A Hall Tracker
              </h1>
              
              <div className="space-y-6 text-slate-300">
                <div className="bg-red-900/30 border border-red-500/50 rounded-lg p-4">
                  <p className="text-red-200 font-bold mb-2">‚ö†Ô∏è Code Insertion Required</p>
                  <p className="text-sm">This deployment file needs the complete App component code.</p>
                </div>

                <div className="bg-blue-900/30 border border-blue-500/50 rounded-lg p-4">
                  <p className="text-blue-200 font-bold mb-3">üìã To Complete Setup:</p>
                  <ol className="list-decimal list-inside space-y-2 text-sm">
                    <li>Ask Claude: "Please provide the complete App component code from remixed-53bdf61a"</li>
                    <li>Copy the code Claude provides</li>
                    <li>Paste it into this file (line 68+)</li>
                    <li>Save as index.html</li>
                    <li>Upload to Vercel</li>
                  </ol>
                </div>

                <div className="bg-green-900/30 border border-green-500/50 rounded-lg p-4">
                  <p className="text-green-200 font-bold mb-3">‚úÖ What's Already Configured:</p>
                  <ul className="list-disc list-inside space-y-1 text-sm">
                    <li>localStorage polyfill (replaces Claude storage)</li>
                    <li>React 18 production build</li>
                    <li>Recharts for graphs</li>
                    <li>Lucide icons</li>
                    <li>Tailwind CSS</li>
                    <li>All CDN dependencies loaded</li>
                  </ul>
                </div>

                <div className="text-center pt-6">
                  <a 
                    href="https://vercel.com/new"
                    target="_blank"
                    rel="noopener noreferrer"
                    className="inline-block bg-gradient-to-r from-purple-600 to-pink-600 hover:from-purple-700 hover:to-pink-700 text-white font-bold py-3 px-8 rounded-lg transition-all"
                  >
                    Deploy to Vercel ‚Üí
                  </a>
                </div>
              </div>
            </div>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>